## **1. Introduction to Python**  
1. [What is Python](#what-is-python)  
2. [What is garbage collection in Python?](#what-is-garbage-collection-in-python) 
3. [What are variables in Python?](#what-are-variables-in-python)  
4. [What are literals in Python?](#what-are-literals-in-python)  
5. [Where Does the Code Get Stored: Heap Memory or Stack?](#where-does-the-code-get-stored-heap-memory-or-stack)


## **4. Data Types in Python**  

1. [What are Python‚Äôs built-in data types?](#what-are-pythons-built-in-data-types)  
2. [How does Python handle memory for mutable and immutable objects?](#how-does-python-handle-memory-for-mutable-and-immutable-objects)  
3. [What is the difference between mutable and immutable data types?](#what-is-the-difference-between-mutable-and-immutable-data-types)  
4. [What is the difference between a list, tuple, and set?](#what-is-the-difference-between-a-list-tuple-and-set)  
5. [What is the difference between shallow copy and deep copy?](#what-is-the-difference-between-shallow-copy-and-deep-copy) 



## **5. Strings in Python**  

1. [What is a string in Python?](#what-is-a-string-in-python)  
2. [What is string slicing? Provide an example.](#what-is-string-slicing-provide-an-example)  
3. [How can you reverse a string in Python?](#how-can-you-reverse-a-string-in-python)  
4. [How do you check if a string contains a substring?](#how-do-you-check-if-a-string-contains-a-substring) 
5. [How do you replace a substring in a string?](#how-do-you-replace-a-substring-in-a-string)  
6. [What are negative indices in Python?](#what-are-negative-indices-in-python)  

## **7. Comprehension in Python**  
1. [What is compheresions and its type](#what-is-compheresions-and-its-type)




## **8. Operators in Python**  

1. [What are Python operators? List different types.](#what-are-python-operators-list-different-types) 


## **9. Conditional Statements**  

1. [What are conditional statements in Python?](#what-are-conditional-statements-in-python)  


## **10. Loops in Python**  

1. [What are loops in Python? Why are they used?](#what-are-loops-in-python-why-are-they-used)  



## **11. Functions in Python**  

1. [What is a function in Python? How do you define one?](#what-is-a-function-in-python-how-do-you-define-one)  
2. [What are `*args` and `**kwargs` in Python?](#what-are-args-and-kwargs-in-python)  
3. [What is lambda function?](#what-is-lambda-function)  
4. [What is the enumerate function in Python?](#what-is-the-enumerate-function-in-python) 
5. [What are higher-order functions in Python?](#what-are-higher-order-functions-in-python) 
6. [What is the use of the reduce function?](#what-is-the-use-of-the-reduce-function) 
7. [What is a function decorator?](#what-is-a-function-decorator) 
8. [What is a Class Decorator?](#what-is-a-class-decorator) 
9. [What is the purpose of the property decorator?](#what-is-the-purpose-of-the-property-decorator)
--


## **12. Iterators and Generators**  

1. [What is an iterator in Python?](#what-is-an-iterator-in-python)  
2. [What are generators? How do they work?](#what-are-generators-how-do-they-work)  

## **13. Exception Handling in Python**  

1. [What is exception handling in Python?](#what-is-exception-handling-in-python)  
2. [What is the difference between syntax errors and runtime errors?](#what-is-the-difference-between-syntax-errors-and-runtime-errors)  
3. [What are built-in exceptions in Python?](#what-are-built-in-exceptions-in-python)  
4. [What is the purpose of `try`, `except`, and `finally` blocks?](#what-is-the-purpose-of-try-except-and-finally-blocks)  
5. [How can you raise an exception in Python?](#how-can-you-raise-an-exception-in-python) 


## **15. Modules and Packages**  

1. [What is a module in Python?](#what-is-a-module-in-python)  
2. [What is the difference between a module and a package?](#what-is-the-difference-between-a-module-and-a-package) 




## **16. Object-Oriented Programming (OOP) in Python**  

1. [What is a class in Python?](#what-is-a-class-in-python)  
2. [What is an object in Python?](#what-is-an-object-in-python)  
3. [What is the purpose of the `__init__` method?](#what-is-the-purpose-of-the-__init__-method)  
4. [What are class variables and instance variables?](#what-are-class-variables-and-instance-variables)  
5. [What is the difference between a class and an object?](#what-is-the-difference-between-a-class-and-an-object)  
6. [What are the four pillars of OOP? Explain each.](#what-are-the-four-pillars-of-oop-explain-each)  
7. [Real-time Example of Each Pillar](#real-time-example-of-each-pillar)  
8. [What is a Constructor?](#what-is-a-constructor) 
9. [Use of `super` and `self` Keyword](#use-of-super-and-self-keyword)
10. [What are Decorators and How to Implement Them?](#what-are-decorators-and-how-to-implement-them)
11. [What is `self` and `__init__`?](#what-is-self-and-__init__)
12. [What is encapsulation? How is it implemented in Python?](#what-is-encapsulation-how-is-it-implemented-in-python)  
13. [What is method overloading? Does Python support it?](#what-is-method-overloading-does-python-support-it)  
14. [What is method overriding? Provide an example.](#what-is-method-overriding-provide-an-example)  
15. [What is the difference between public, private, and protected members in Python?](#what-is-the-difference-between-public-private-and-protected-members-in-python)  
16. [How does Python method resolution order work in multiple inheritance?](#how-does-python-method-resolution-order-work-in-multiple-inheritance) 
17. [What is operator overloading??](#what-is-operator-overloading)




## Difference of all topics

1. [Difference between tuple and dictionary](#difference-between-tuple-and-dictionary)
2. [Difference between tuple and set](#difference-between-tuple-and-set)
3. [Difference between map() and filter()](#difference-between-map-and-filter)
6. [Difference between append() and extend()](#difference-between-append-and-extend)
9. [Difference between remove() and pop()](#difference-between-remove-and-pop)
11. [Difference between split() and partition()](#difference-between-split-and-partition)
12. [Difference between find() and index()](#difference-between-find-and-index)
13. [Difference between upper() and capitalize()](#difference-between-upper-and-capitalize)
31. [Difference between global scope and local scope](#difference-between-global-scope-and-local-scope)
27. [Difference between remove() and discard() in Sets](#difference-between-remove-and-discard-in-sets)
36. [difference between encapsulation and abstraction?](#difference-between-encapsulation-and-abstraction)






## **1. Introduction to Python**  

1. ### What is Python
    Python is a **high-level, interpreted, and dynamically typed** programming language. It is known for its **simplicity, readability, and ease of use**. Python supports multiple programming paradigms, including **procedural, object-oriented, and functional programming**.  

    It is widely used in various fields, such as:  
    - **Web Development** (Django, Flask)  
    - **Data Science & Machine Learning** (Pandas, NumPy, Scikit-learn)  
    - **Automation & Scripting**  
    - **Cybersecurity & Ethical Hacking**  
    - **Embedded Systems & IoT**  

    Python is also **cross-platform** and has a **large standard library**, making it one of the most popular programming languages today. üöÄ  


2. ###  What is garbage collection in Python

    #### **Garbage Collection in Python**  

    #### **What is Garbage Collection?**  
    Garbage collection is the process of **automatically managing memory** by reclaiming unused objects that are no longer accessible, preventing memory leaks and optimizing resource usage.  

    #### **How Garbage Collection Works in Python?**  
    Python uses **two techniques** for garbage collection:  
    1. **Reference Counting**  
    2. **Cycle-Detecting Garbage Collector**  

    #### **1. Reference Counting**  
    - Every object in Python has a **reference count**, which tracks how many references point to it.  
    - When the reference count drops to **zero**, Python **immediately deallocates** the object.  
    - **Example:**  
    ```python
    import sys
    x = [1, 2, 3]  
    print(sys.getrefcount(x))  # Returns the reference count
    #### **Advantages of Garbage Collection in Python**
    ```
    ‚úî **Automatic memory management** ‚Äì Reduces developer effort. 
    ‚úî **Prevents memory leaks** ‚Äì Clears unused memory. 
    ‚úî **Optimizes performance** ‚Äì Ensures efficient memory usage.


    #### **Disadvantages of Garbage Collection**

    ‚ùå **Consumes CPU time** ‚Äì Can cause minor slowdowns. 
    ‚ùå **Not immediate for cyclic references** ‚Äì Depends on periodic execution.


    [geeksforgeek](https://www.geeksforgeeks.org/memory-management-in-python/)




3. ### What are variables in Python
    A **variable** in Python is a **named storage location** used to store data. It acts as a container that holds values, which can be changed during program execution.



    #### üîπ **Declaring and Assigning Variables**  
    In Python, you don't need to declare the type of a variable explicitly. It is dynamically inferred based on the value assigned.

    ```python
    x = 10         # Integer variable
    name = "Alice" # String variable
    pi = 3.14      # Float variable
    is_valid = True # Boolean variable

    print(x)      
    print(name)    
    print(pi)     
    print(is_valid)  

    # Output:
    # 10
    # Alice
    # 3.14
    # True
    ```

    **üîπ Variable Naming Rules**
    ‚úî Must start with a letter (a-z, A-Z) or underscore _
    ‚úî Cannot start with a number (e.g., ```1var``` is invalid)
    ‚úî Can only contain letters, digits, and underscores
    ‚úî Case-sensitive (```myVar``` and ```myvar``` are different)
    ‚úî Cannot be a Python keyword (```def```, ```if```, ```else```, ```etc```.)

    **‚úÖ Valid Variable Names**
    ```python
    age = 25
    _name = "John"
    user123 = "Python"

    ```
    **‚ùå Invalid Variable Names**
    ```python
    1name = "Alice"  # ‚ùå Cannot start with a number
    my-name = "Bob"  # ‚ùå Hyphens are not allowed
    def = 10         # ‚ùå Cannot use keywords

    ```
    **üîπ Reassigning Variables**
    You can change the value of a variable at any time:

    ```python
    x = 5
    print(x)  # Output: 5

    x = "Hello"
    print(x)  # Output: Hello
    ```
    ‚úÖ Python allows **changing data types** because it is **dynamically typed**.

    **üéØ Conclusion**
    ‚úÖ **Variables store values** that can change during execution.

    ‚úÖ **Python is dynamically typed**, so variable types are inferred.

    ‚úÖ **Follow naming rules** to avoid syntax errors. üöÄ




4. ### What are literals in Python
    Literals in Python are fixed values assigned directly to variables or constants. They represent data without requiring computation. Python has different types of literals:  

    #### 1. **String Literals**  
    Represent text enclosed in single, double, or triple quotes.  

    ```python
    single_quote = 'Hello'
    double_quote = "Hello"
    triple_quote = '''Hello, this is a multi-line string'''
    ```

    #### 2. Numeric Literals
    Include integers, floating-point numbers, and complex numbers.

    ```python
    integer_num = 10         # Integer literal
    float_num = 3.14         # Float literal
    complex_num = 3 + 4j     # Complex literal

    ```
    #### 3. Boolean Literals
    Represent truth values: True or False.

    ```python
    is_python_easy = True
    is_java_better = False
    ```
    #### 4. Special Literal
    Python provides a special literal None to indicate the absence of a value.

    ```python
    no_value = None
    ```
    #### 5. List, Tuple, Dictionary, and Set Literals
    Collections of data in different formats.

    ```python
    list_literal = [1, 2, 3, "Python"]     # List literal
    tuple_literal = (10, 20, 30)           # Tuple literal
    dict_literal = {'name': 'Alice', 'age': 25}  # Dictionary literal
    set_literal = {1, 2, 3, 4}             # Set literal
    ```
    Literals make code more readable and easy to understand. üöÄ


5. ### Where Does the Code Get Stored Heap Memory or Stack


    ### **Understanding Memory Storage in Python**
    Python uses two types of memory storage:

    1. **Stack Memory**: Stores function calls, local variables, and control flow data.
    2. **Heap Memory**: Stores objects, instances, and dynamically allocated data.

    ---

    ### **Stack Memory**
    - Used for storing local function variables and control flow.
    - Operates in a Last In, First Out (LIFO) manner.
    - Automatically managed, meaning variables are destroyed after function execution.

    #### **Example: Stack Memory in Function Calls**
    ```python
    def function_a():
        x = 10  # Stored in stack memory
        function_b()
        print("End of function A")

    def function_b():
        y = 20  # Stored in stack memory
        print("Inside function B")

    function_a()
    ```
    #### **Output:**
    ```
    Inside function B
    End of function A
    ```

    ---

    ### **Heap Memory**
    - Stores dynamically allocated memory like objects and instances.
    - Managed by Python's garbage collector.
    - Objects persist beyond function calls if referenced elsewhere.

    #### **Example: Heap Memory in Object Creation**
    ```python
    class Person:
        def __init__(self, name):
            self.name = name  # Stored in heap memory

    def create_person():
        p = Person("Alice")  # `p` is stored in stack, but `name` is in heap
        return p

    person_instance = create_person()
    print(person_instance.name)
    ```
    #### **Output:**
    ```
    Alice
    ```

    ---

    ### **Key Differences Between Stack and Heap Memory**
    | Feature          | Stack Memory | Heap Memory |
    |-----------------|-------------|-------------|
    | Storage Type    | Local variables, function calls | Objects, instances, dynamically allocated data |
    | Access Speed   | Faster | Slower |
    | Scope          | Limited to function execution | Global if referenced |
    | Memory Management | Automatic | Garbage collection required |

    ---

    ### **Conclusion**
    - **Stack Memory**: Used for function calls and local variables, automatically managed.
    - **Heap Memory**: Stores objects and dynamically allocated memory, requiring garbage collection.
    - Efficient memory management is crucial for optimizing Python applications.


## **4. Data Types in Python**


1. ### What are Python‚Äôs built-in data types
    #### **Built-in Data Types in Python (Detailed Explanation)**

    Python provides a variety of **built-in data types** to store and manipulate different kinds of data efficiently. These data types are categorized into **Immutable Data Types** (which cannot be changed after creation) and **Mutable Data Types** (which can be modified after creation).

    #### **Immutable Data Types**


    #### **1. int (Integer)**

    The `int` data type is used to represent whole numbers (both positive and negative) without any decimal point. It supports mathematical operations like addition, subtraction, multiplication, and division.



    * **Example:**


    ```python
    x = 42
    y = -10
    print(type(x), type(y))  # Output: <class 'int'> <class 'int'>

    ```



    * **Use Case:** Used in counting, indexing, loops, and arithmetic calculations. 

    #### **2. float (Floating-Point Number)**

    The `float` data type represents numbers with decimal points. It is commonly used for calculations that require precision, such as scientific and financial computations.



    * **Example:**


    ```python
    pi = 3.14
    negative_float = -0.01
    print(type(pi))  # Output: <class 'float'>

    ```

    * **Use Case:** Used in temperature measurement, percentage calculations, and statistical data processing. 

    #### **3. complex (Complex Numbers)**

    Python supports complex numbers, consisting of a **real** and **imaginary** part, represented as `a + bj`, where `j` is the imaginary unit.

    * **Example:**


    ```python
    z = 3 + 4j
    print(type(z))  # Output: <class 'complex'>

    ```



    * **Use Case:** Used in mathematical computations involving imaginary numbers, such as electrical engineering and signal processing. 


    #### **4. bool (Boolean)**

    The `bool` type represents **True** or **False** values, which are used for logical operations and conditions.

    * **Example:**

    ```python
    is_python_fun = True
    print(type(is_python_fun))  # Output: <class 'bool'>

    ```



    * **Use Case:** Used in decision-making (if-else statements), logical conditions, and comparisons. 

    #### **5. str (String)**

    A `str` represents a **sequence of Unicode characters** enclosed in single, double, or triple quotes.

    * **Example:**


    ```python
    greeting = "Hello, World!"
    print(type(greeting))  # Output: <class 'str'>

    ```



    * **Use Case:** Used in text processing, data storage, and user interactions. 

    #### **6. tuple (Tuple)**

    A `tuple` is an **ordered** collection of elements that is **immutable** (cannot be changed after creation).
    * **Example:**


    ```python
    coordinates = (10, 20, 30)
    print(type(coordinates))  # Output: <class 'tuple'>

    ```
    * **Use Case:** Used when a fixed collection of items is needed, such as days of the week or geographical coordinates. 

    #### **7. frozenset (Immutable Set)**

    A `frozenset` is an **unordered** collection of unique elements that **cannot be modified** after creation.
    * **Example:**


    ```python
    frozen_numbers = frozenset([1, 2, 3, 4, 5])
    print(type(frozen_numbers))  # Output: <class 'frozenset'>

    ```
    * **Use Case:** Used in scenarios where a set must remain constant, such as defining unchangeable configuration values.

    #### **8. bytes (Byte Data Type)**

    The `bytes` type represents a sequence of **immutable** 8-bit bytes, often used in binary data manipulation.
    * **Example:**


    ```python
    byte_data = b"hello"
    print(type(byte_data))  # Output: <class 'bytes'>

    ```



    * **Use Case:** Used in file handling, network communication, and cryptographic operations. 
    #### **9. bytearray (Mutable Byte Data Type)**

    A `bytearray` is similar to `bytes`, but it **allows modification** of byte values.



    * **Example:**


    ```python
    mutable_bytes = bytearray(5)
    print(type(mutable_bytes))  # Output: <class 'bytearray'>

    ```



    * **Use Case:** Used in applications that require modification of binary data, such as image or audio processing. 


    #### **10. NoneType (None Value)**

    `NoneType` represents the **absence of a value** and is commonly used as a default return value for functions that do not explicitly return anything.



    * **Example:**


    ```python
    x = None
    print(type(x))  # Output: <class 'NoneType'>

    ```
    * **Use Case:** Used in functions, placeholders, and optional values in variables. 

    ## **Mutable Data Types**


    #### **1. list (List)**

    A `list` is an **ordered and mutable** collection that can store different data types.



    * **Example:**


    ```python
    fruits = ["apple", "banana", "cherry"]
    fruits.append("orange")
    print(type(fruits))  # Output: <class 'list'>

    ```

    * **Use Case:** Used when a dynamic collection of elements is needed, such as storing user inputs or database records. 

    #### **2. set (Set)**

    A `set` is an **unordered** collection of **unique** elements.

    * **Example:**

    ```python
    unique_numbers = {1, 2, 3, 4}
    print(type(unique_numbers))  # Output: <class 'set'>

    ```

    * **Use Case:** Used for mathematical operations like union, intersection, and removing duplicates. 

    #### **3. dict (Dictionary)**

    A `dict` stores **key-value pairs**, making it easy to retrieve values based on keys.

    * **Example:**


    ```python
    student = {"name": "Alice", "age": 20}
    print(type(student))  # Output: <class 'dict'>

    ```
    * **Use Case:** Used in APIs, configuration files, and structured data storage. 

    #### **4. memoryview (Memory Management)**

    The `memoryview` type allows direct manipulation of binary data without copying it.



    * **Example:**

    ```python
    data = memoryview(bytes(5))
    print(type(data))  # Output: <class 'memoryview'>

    ```



    * **Use Case:** Used in high-performance computing for efficient memory management. 



    #### **5. array (Array)**

    An `array` stores elements of the **same data type** (requires `array` module).



    * **Example:**


    ```python
    import array
    arr = array.array('i', [1, 2, 3, 4])
    print(type(arr))  # Output: <class 'array.array'>

    ```

    * **Use Case:** Used in performance-sensitive applications requiring homogeneous data. 

    #### **6. deque (Double-Ended Queue)**

    A `deque` (double-ended queue) allows **fast insertion and removal** from both ends.

    * **Example:**
    ```python
    from collections import deque
    dq = deque([1, 2, 3, 4])
    print(type(dq))  # Output: <class 'collections.deque'>

    ```
    * **Use Case:** Used in queue-based applications and sliding window problems. 

    #### **7. object (Base Class)**

    `object` is the base class from which all Python classes inherit.

    * **Example:**
    ```python
    class Sample:
        pass

    obj = Sample()
    print(type(obj))  # Output: <class '__main__.Sample'>

    ```
    * **Use Case:** Used as a foundation for creating new classes. 
    #### **8. types.SimpleNamespace (Dynamic Attribute Assignment)**

    Allows dynamic assignment of attributes.

    * **Example:**
    ```python
    from types import SimpleNamespace
    person = SimpleNamespace(name="John", age=30)
    print(type(person))  # Output: <class 'types.SimpleNamespace'>
    ```
    * **Use Case:** Used in object-like structures with dynamic properties. 

    #### **Conclusion**

    Understanding **Python‚Äôs built-in data types** allows for **efficient programming** and **better memory management**. Choosing the right data type improves **code performance, readability, and maintainability**.


2. ### How does Python handle memory for mutable and immutable objects

    #### **How Python Handles Memory for Mutable and Immutable Objects**  

    #### **Understanding Mutable and Immutable Objects**  
    In Python, objects are classified as **mutable** (can be changed after creation) and **immutable** (cannot be changed after creation).  
    - **Mutable objects**: Lists, Dictionaries, Sets, Byte Arrays  
    - **Immutable objects**: Integers, Strings, Tuples, Floats, Booleans  

    #### **Memory Handling in Python**  

    #### **1. Immutable Objects (Efficient Memory Usage)**  
    - Stored in a **fixed memory location**.  
    - Python **reuses existing memory** for immutable objects with the same value (interning).  
    - **Example:**  
    ```python
    a = 10
    b = 10
    print(id(a) == id(b))  # True, both reference the same memory location
    ```
    #### **2. Mutable Objects (Independent Memory Allocation)**

    * Stored in **heap memory** and referenced by variables. 

    * When modified, **changes apply to the same memory location**. 


        **Example:** 
    `list1 = [1, 2, 3]`


        ```python
        list2 = list1  # Both point to the same object in memory
        list1.append(4)
        print(list2)  # Output: [1, 2, 3, 4]
        ```


    * Since lists are **mutable**, modifying one reference **affects all variables pointing to the same object**.
    #### **Key Differences in Memory Handling**

    | Feature              | Mutable Objects                | Immutable Objects          |
    |----------------------|--------------------------------|----------------------------|
    | **Memory Allocation** | Stored in Heap Memory         | Stored in an optimized way (interning) |
    | **Reference Behavior** | Multiple references point to the same object | New object is created when modified |
    | **Modification Effect** | Modifies the existing object | Creates a new object when changed |
    | **Examples**         | Lists, Dictionaries, Sets     | Integers, Strings, Tuples  |
   
3. ### What is the difference between mutable and immutable data types

    #### **1. Mutable Data Types**

    Mutable objects can be **modified** after they are created. This means you can change their content without changing their identity (memory address).


    #### **Key Characteristics of Mutable Data Types:**



    * **Modifiable:** The contents of the object can be changed.

    * **Same Memory Address:** When modified, the object retains the same memory address.

    * **Higher Memory Usage:** As mutable objects are modified in place, they may consume more memory.

    * **Performance Impact:** Since they can be changed, special handling is needed in concurrent programming.



    #### **Examples of Mutable Data Types:**



    * **Lists (list)**
    * **Dictionaries (dict)**
    * **Sets (set)**
    * **Byte Arrays (bytearray)**


    #### **Example: Mutable Object (List)**


    ```python
    my_list = [1, 2, 3]
    print(id(my_list))  # Output: Memory address of my_list

    my_list.append(4)  # Modifying the list
    print(my_list)  # Output: [1, 2, 3, 4]
    print(id(my_list))  # Same memory address as before
    ```


    üëâ The list remains at the same memory location even after modification.


    ---


    #### **2. Immutable Data Types**

    Immutable objects **cannot be modified** after creation. Any modification results in the creation of a **new object** with a different memory address.


    #### **Key Characteristics of Immutable Data Types:**



    * **Unchangeable:** Once created, the object‚Äôs value cannot be changed.

    * **New Memory Address:** If modified, a new object is created.

    * **Efficient in Memory Usage:** Since immutable objects don‚Äôt change, Python can optimize memory usage.

    * **Thread-Safe:** They are safe for multi-threaded environments as their state cannot be modified.



    #### **Examples of Immutable Data Types:**



    * **Integers (int)**
    * **Floats (float)**
    * **Strings (str)**
    * **Tuples (tuple)**
    * **Booleans (bool)**
    * **Frozen Sets (frozenset)**
    * **Bytes (bytes)**


    #### **Example: Immutable Object (String)**


    ```python
    my_string = "Hello"
    print(id(my_string))  # Output: Memory address of my_string

    my_string += " World"  # Attempt to modify the string
    print(my_string)  # Output: "Hello World"
    print(id(my_string))  # New memory address
    ```


    üëâ Since strings are immutable, Python creates a **new object** instead of modifying the existing one.
    #### **Difference Between Mutable and Immutable Data Types**

    | Feature              | Mutable Data Types           | Immutable Data Types      |
    |----------------------|-----------------------------|---------------------------|
    | **Definition**       | Can be changed after creation | Cannot be changed after creation |
    | **Memory Behavior**  | Modifications happen in place | New object is created when modified |
    | **Examples**        | Lists, Dictionaries, Sets   | Strings, Tuples, Integers, Floats |
    | **Performance**     | May have higher memory usage due to in-place changes | More memory efficient due to object reuse |
    | **Usage**          | Useful when frequent modifications are needed | Useful when data should remain constant |
    #### **4. Why is This Important?**



    * **Efficiency:** Knowing when to use mutable vs. immutable objects can help in optimizing memory usage. 

    * **Avoiding Bugs:** Accidentally modifying a mutable object shared across multiple functions can lead to unexpected behavior. 

    * **Performance Considerations:** Immutable objects can be **cached** and reused, improving efficiency. 

    #### **Conclusion**



    * **Use Mutable objects** when you need to frequently modify data (e.g., Lists, Dictionaries). 

    * **Use Immutable objects** when you want to ensure data consistency and prevent accidental modifications (e.g., Strings, Tuples). 

    * Understanding the distinction helps in writing more efficient and bug-free Python programs.

4. ### What is the difference between a list, tuple, and set

    #### **Difference Between List, Tuple, and Set in Python**

    In Python, **lists**, **tuples**, and **sets** are used to store collections of items. However, they have different properties and use cases.


    ---


    #### **Characteristics of a List:**



    * **Mutable** (modifiable after creation) 

    * **Ordered** (elements maintain their sequence) 

    * **Allows duplicates** (can contain the same value multiple times) 

    * **Indexable** (supports indexing and slicing) 

    * **Uses square brackets [] 



    #### Example of a List:


    ```python
    my_list = [1, 2, 3, 2, 4]
    my_list.append(5)  # Modifying the list
    print(my_list)  # Output: [1, 2, 3, 2, 4, 5]
    ```


    üìå **When to use a List? 
    ** Use a list when you need to frequently modify or reorder the collection.


    ---


    #### **2. Tuple**

    A **tuple** is an **ordered**, **immutable**, and **indexed** collection of items. It allows duplicate values.


    #### **Characteristics of a Tuple:**



    * **Immutable** (cannot be modified after creation) 

    * **Ordered** (maintains sequence) 

    * **Allows duplicates** (can contain the same value multiple times) 

    * **Indexable** (supports indexing and slicing) 

    * **Uses parentheses () 



    #### Example of a Tuple:


    ```python
    my_tuple = (1, 2, 3, 2, 4)
    print(my_tuple[1])  # Output: 2
    # my_tuple[1] = 5  # ‚ùå This will raise an error because tuples are immutable
    ```


    üìå **When to use a Tuple? 
    ** Use a tuple when the data should remain **constant** and unchangeable.


    ---


    #### **3. Set**

    A **set** is an **unordered**, **mutable**, and **unindexed** collection of **unique** elements.


    #### **Characteristics of a Set:**



    * **Mutable** (can add or remove elements) 

    * **Unordered** (does not maintain sequence) 

    * **Does not allow duplicates** (only unique values) 

    * **Unindexed** (does not support indexing) 

    * **Uses curly braces {}**



    #### Example of a Set:


    ```python
    my_set = {1, 2, 3, 2, 4}
    print(my_set)  # Output: {1, 2, 3, 4} (removes duplicates)
    my_set.add(5)  
    print(my_set)  # Output: {1, 2, 3, 4, 5}
    ```


    üìå **When to use a Set?** 
    Use a set when you need a **collection of unique items** and don't care about order.

    | Feature       | List `[]` | Tuple `()` | Set `{}` |
    |--------------|----------|------------|----------|
    | **Mutability** | ‚úÖ Mutable (can be modified) | ‚ùå Immutable (cannot be modified) | ‚úÖ Mutable (can add/remove items) |
    | **Ordering**  | ‚úÖ Ordered | ‚úÖ Ordered | ‚ùå Unordered |
    | **Duplicates** | ‚úÖ Allows duplicates | ‚úÖ Allows duplicates | ‚ùå No duplicates |
    | **Indexing** | ‚úÖ Supports indexing & slicing | ‚úÖ Supports indexing & slicing | ‚ùå No indexing |
    | **Performance** | Slower (mutable) | Faster (immutable) | Fast lookups (due to hashing) |
    | **Use Case** | When you need to modify data | When data should remain constant | When you need unique items |

5. ### What is the difference between shallow copy and deep copy
    #### **Difference Between Shallow Copy and Deep Copy in Python**


    #### **1. Understanding Copying in Python**

    In Python, copying an object means creating a new object with the same content as the original object. However, the way data is copied varies depending on **shallow copy** and **deep copy**.


    ---


    ## **Shallow Copy**


    #### **Definition:**

    A **shallow copy** creates a new object, but instead of copying the inner objects (nested lists, dictionaries, etc.), it only **copies references** to those objects.


    #### **How It Works:**



    * If the original object contains mutable objects (like lists inside a list), the shallow copy will **share the references** of those objects. 

    * Modifications inside **nested mutable objects** will affect both the original and copied object. 

    * However, changes to **top-level elements** (like replacing an item in a list) do not affect the original object. 



    #### **Example of Shallow Copy:**


    ```python
    import copy

    original_list = [[1, 2, 3], [4, 5, 6]]
    shallow_copied_list = copy.copy(original_list)  # Creates a shallow copy

    shallow_copied_list[0][0] = 100  # Modifying the nested list

    print(original_list)        # [[100, 2, 3], [4, 5, 6]]
    print(shallow_copied_list)  # [[100, 2, 3], [4, 5, 6]]
    ```


    **Observation:**



    * Both the original and copied lists are affected because they share the reference to the same nested list. 



    ---


    ## **Deep Copy**


    #### **Definition:**

    A **deep copy** creates a new object and **recursively copies all the objects inside it**, ensuring that **nested objects get duplicated** instead of sharing references.


    #### **How It Works:**



    * Changes to the nested objects inside the deep copy **do not affect the original object**. 

    * The deep copy creates completely independent copies of all the inner objects. 



    #### **Example of Deep Copy:**


    ```python
    import copy

    original_list = [[1, 2, 3], [4, 5, 6]]
    deep_copied_list = copy.deepcopy(original_list)  # Creates a deep copy

    deep_copied_list[0][0] = 100  # Modifying the nested list

    print(original_list)       # [[1, 2, 3], [4, 5, 6]]
    print(deep_copied_list)    # [[100, 2, 3], [4, 5, 6]]
    ```


    **Observation:**



    * The original list remains **unchanged**, proving that a deep copy creates independent objects. 


    | Feature       | Shallow Copy | Deep Copy |
    |--------------|-------------|-----------|
    | **Copying Method** | Copies references of nested objects | Recursively copies all nested objects |
    | **Nested Objects** | Shared between original and copied object | Completely independent objects |
    | **Memory Usage** | Uses less memory (since references are shared) | Uses more memory (since new objects are created) |
    | **Performance** | Faster (just copying references) | Slower (creates new objects) |
    | **Effect of Modification** | Changes in nested objects reflect in both copies | Changes in one object don‚Äôt affect the other |
    | **Use Case** | When objects are mostly unchanged or immutable | When objects need full independence |





## **5. Strings in Python**
1. ### What is a string in python

    ### **How to Describe "String" in an Interview ‚Äì Step-by-Step Approach**  

    If you're asked about Strings in an interview, follow this structured way to explain it clearly and confidently.  

    ---

    ### **1Ô∏è‚É£ Start with a Clear Definition**  

    #### **One-line definition:**  
    > "A string is a sequence of characters enclosed in quotes, used to store and manipulate text in programming."

    #### **Example:**  
    ```python
    text = "Hello, World!"
    ``` 
    ### **2Ô∏è‚É£ Explain the Importance of Strings**


    #### **Why are strings important?**



    * Strings are used everywhere in programming: for user inputs, messages, file handling, web development, and data processing. 

    * Many programming languages provide built-in methods to manipulate strings easily. 



    #### **Example:**


    "In web development, strings store user inputs like names, emails, and passwords."


    ---


    ### **3Ô∏è‚É£ Describe How Strings Work**



    * Strings are stored as a sequence of characters in memory. 

    * Strings can be **immutable** (cannot be changed after creation) in languages like Python and Java. 

    * Strings are **indexed**, meaning you can access characters by position. 



    #### **Example (Indexing in Python):**


    ```python
    word = "Python"
    print(word[0])  # Output: P
    print(word[-1])  # Output: n (Last character)
    ```



    "Here, `word[0]` accesses the first character, and `word[-1]` gets the last character."


    ---


    ### **4Ô∏è‚É£ Provide a Simple Code Example**


    #### **Show basic string operations like concatenation, slicing, and formatting.**


    #### **Example (String Operations in Python):**


    ```python
    # Concatenation
    name = "John"
    greeting = "Hello, " + name  # "Hello, John"

    # Slicing
    text = "Python"
    print(text[0:3])  # "Pyt"

    # Formatting
    age = 25
    sentence = f"My age is {age}."
    ```



    "This shows how to concatenate, slice, and format strings dynamically."


    ---


    ### **5Ô∏è‚É£ Mention Real-World Applications**


    #### **Where do we use strings in real life?**



    * **Web Development**: Storing form inputs (e.g., username, passwords). 

    * **Data Science**: Processing textual data (e.g., sentiment analysis). 

    * **Databases**: Storing and querying text data. 

    * **Logging & Debugging**: Storing error messages and logs. 



    #### **Example:**


    "In chat applications like WhatsApp, messages are stored and processed as strings."


    ---


    ### **6Ô∏è‚É£ Discuss Advanced or Interesting Points**



    * **Are strings mutable or immutable?**
    * **How are strings stored in memory?**
    * **Performance considerations (e.g., using join() instead of + for concatenation in Python).**


    #### **Example (Efficiency in Python):**


    ```python
    # Inefficient (Creates multiple string copies)
    result = ""
    for word in ["Hello", "World"]:
        result += word  # Slow

    # Efficient (Uses join method)
    result = " ".join(["Hello", "World"])
    ```



    "Using `.join()` is faster because it reduces memory overhead."


    ---


    ### **7Ô∏è‚É£ Conclude with Confidence**


    #### **Summarize the key points:**


    "In summary, strings are essential for handling text data in programming. They are immutable in many languages, indexed for easy access, and offer various built-in operations. Would you like me to explain string manipulation in more detail?"


    ---


    #### **üí° Bonus Tips for Students**



    * **Use structured thinking**: Definition ‚Üí Importance ‚Üí How It Works ‚Üí Example ‚Üí Real-World Uses ‚Üí Advanced Points 

    * **Be concise & clear**: Avoid over-explaining. 

    * **Use analogies**: "Think of a string as a chain of characters stored in order." 

    * **Practice aloud**: It improves fluency and confidence.
    #### **Escape Characters in Strings**

    Escape characters are special sequences used to represent unprintable or reserved characters in strings.

    | Escape Character | Description |
    |-----------------|-------------|
    | `n` | New line (moves text to the next line) |
    | `t` | Tab space (adds horizontal space) |
    | `` | Backslash (inserts a single `` in text) |
    | `'` | Single quote (allows `'` inside single-quoted strings) |
    | `"` | Double quote (allows `"` inside double-quoted strings) |
    | `r` | Carriage return (moves cursor to line start) |
    | `b` | Backspace (removes previous character) |

    ---

    #### **String Functions (With 5-Word Descriptions)**  

    | Function | Description |
    |----------|-------------|
    | `len(s)` | Returns string length count. |
    | `s.upper()` | Converts text to uppercase. |
    | `s.lower()` | Converts text to lowercase. |
    | `s.title()` | Capitalizes first letter words. |
    | `s.strip()` | Removes surrounding whitespace characters. |
    | `s.replace(a, b)` | Replaces `a` with `b`. |
    | `s.split(d)` | Splits string at `d`. |
    | `s.join(list)` | Joins list into string. |
    | `s.find(x)` | Finds `x` position index. |
    | `s.count(x)` | Counts occurrences of `x`. |
    | `s.startswith(x)` | Checks if starts with `x`. |
    | `s.endswith(x)` | Checks if ends with `x`. |
    | `s.isdigit()` | Checks if all numbers. |
    | `s.isalpha()` | Checks if all letters. |
    



2. ### What is string slicing? Provide an example

    ### **Slicing in Python**

    ### **Definition**
    Slicing is a technique used to extract a portion of a sequence (like a list, tuple, or string) by specifying a range of indices.

    ### **Syntax**
    ```python
    sequence[start:stop:step]
    ```
    * start: Starting index (inclusive). Defaults to 0 if not specified. 
    
    * stop: Ending index (exclusive). The slice stops before this index. 
    
    * step: The interval between elements. Defaults to 1 if not specified. 



    ---


    ### **Examples**


    #### **List Slicing**


    ```python
    numbers = [0, 1, 2, 3, 4, 5, 6]
    print(numbers[1:5])   # Output: [1, 2, 3, 4]
    print(numbers[:4])    # Output: [0, 1, 2, 3]
    print(numbers[2:])    # Output: [2, 3, 4, 5, 6]
    print(numbers[::2])   # Output: [0, 2, 4, 6]
    print(numbers[::-1])  # Output: [6, 5, 4, 3, 2, 1, 0]  (Reversed list)
    ```



    #### **String Slicing**


    ```python
    text = "Hello World"
    print(text[0:5])   # Output: 'Hello'
    print(text[-5:])   # Output: 'World'


    
    ```



    #### **Negative Indexing**



    * Negative indices can be used to count from the end of the sequence. 

    * Example: `sequence[-1]` refers to the last element. 



    ---


    #### **Use Cases of Slicing**

    ‚úÖ Extracting substrings or sublists. 

    ‚úÖ Reversing strings or lists. 

    ‚úÖ Skipping elements in a sequence.











3. ### How can you reverse a string in Python

    #### **1Ô∏è‚É£ Using Slicing (Recommended)**


    ```python
    text = "Hello"
    reversed_text = text[::-1]
    print(reversed_text)  # Output: "olleH"
    ```


    ‚úÖ **Fastest and most Pythonic way. 
    ** ‚úÖ Uses slicing with a step of `-1` to iterate backward.


    ---


    #### **2Ô∏è‚É£ Using the reverse() Function**


    ```python
    text = "Hello"
    reversed_text = "".join(reversed(text))
    print(reversed_text)  # Output: "olleH"
    ```


    ‚úÖ Returns an iterator that is joined back into a string. 
    ‚úÖ Efficient and readable.


    ---


    #### **3Ô∏è‚É£ Using a Loop (Manual Method)**


    ```python
    text = "Hello"
    reversed_text = ""
    for char in text:
        reversed_text = char + reversed_text
    print(reversed_text)  # Output: "olleH"
    ```


    üö´ **Not recommended for large strings** (slower due to string concatenation).


    ---


    #### **4Ô∏è‚É£ Using reduce() from functools**


    ```python
    from functools import reduce

    text = "Hello"
    reversed_text = reduce(lambda x, y: y + x, text)
    print(reversed_text)  # Output: "olleH"
    ```


    ‚úÖ Functional programming approach. 
    üö´ Less readable than slicing or reversed.


    ---


    #### **Conclusion**



    * ‚úÖ **Best Method:** **Slicing ([::-1])** is the most efficient and recommended approach. 

    * üîπ Use reversed when you want an iterator or performance benefits in some cases. 

    * üîπ Loops or **reduce() ** work but are **less efficient and less readable**.




4. ### How do you check if a string contains a substring
In Python, you can check if a string contains a substring using the `in` keyword.

**Example:**
```python
text = "Hello, welcome to Python programming!"
if "Python" in text:
    print("Substring found!")
else:
    print("Substring not found.")
```


5. ### How do you replace a substring in a string
In Python, the `.replace()` method is used to replace occurrences of a substring within a string.

### Syntax:
```python
string.replace(old, new, count)
```

Example 1 ‚Äì Replace all:

```python
text = "Python is great. Python is easy."
updated_text = text.replace("Python", "Java")
print(updated_text)
```


6. ### What are negative indices in Python
    #### **What are Negative Indexes and Why are They Used?**


    #### **Definition:**

    Negative indexing in Python allows accessing elements from the end of a sequence (like lists, tuples, and strings) by using negative numbers.


    #### **How It Works:**



    * The last element has an index of **-1**. 

    * The second last element has an index of **-2**, and so on. 



    #### **Example:**


    ```python
    numbers = [10, 20, 30, 40, 50]

    print(numbers[-1])  # Output: 50 (Last element)
    print(numbers[-2])  # Output: 40 (Second last element)
    print(numbers[-3])  # Output: 30
    ```



    #### **Why Use Negative Indexing?**

    ‚úÖ **Easier access to the last elements** without calculating length. 
    ‚úÖ **Useful in slicing** to extract elements from the end. 
    ‚úÖ **Avoid len() function calls**, making the code cleaner.


    #### **Example - Negative Indexing in Strings:**


    ```python
    text = "Python"

    print(text[-1])  # Output: 'n'
    print(text[-3:]) # Output: 'hon' (Last three characters)
    ```


    **Conclusion:** Negative indexing simplifies working with sequences by allowing direct access to elements from the end, making the code more readable and efficient. üöÄ




## **7. Comprehension in Python** 
### What is compheresions and its type
## **What is Comprehension and Its Types?**

### **Definition:**
Comprehension in Python is a concise way to create sequences like lists, sets, and dictionaries using a single line of code. It improves code readability and efficiency.

### **Types of Comprehension:**
Python supports four types of comprehensions:

1. **List Comprehension**
2. **Set Comprehension**
3. **Dictionary Comprehension**
4. **Generator Comprehension**

### **1. List Comprehension**

#### **Syntax:**
```python
[expression for item in iterable if condition]
```

#### **Example:**
```python
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = [num for num in numbers if num % 2 == 0]
print(even_numbers)  # Output: [2, 4, 6]
```

#### **Key Points:**
- List comprehension is used to create lists efficiently.
- It can include conditions to filter elements.

---

### **2. Set Comprehension**

#### **Syntax:**
```python
{expression for item in iterable if condition}
```

#### **Example:**
```python
numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = {num for num in numbers}
print(unique_numbers)  # Output: {1, 2, 3, 4, 5}
```

#### **Key Points:**
- Similar to list comprehension but creates a set.
- Automatically removes duplicate values.

---

### **3. Dictionary Comprehension**

#### **Syntax:**
```python
{key_expression: value_expression for item in iterable if condition}
```

#### **Example:**
```python
numbers = [1, 2, 3, 4]
square_dict = {num: num ** 2 for num in numbers}
print(square_dict)  # Output: {1: 1, 2: 4, 3: 9, 4: 16}
```

#### **Key Points:**
- Used to create dictionaries in a concise way.
- Can transform keys and values dynamically.

---

### **4. Generator Comprehension**

#### **Syntax:**
```python
(expression for item in iterable if condition)
```

#### **Example:**
```python
numbers = [1, 2, 3, 4, 5]
gen = (num ** 2 for num in numbers)
print(next(gen))  # Output: 1
print(next(gen))  # Output: 4
```

#### **Key Points:**
- Similar to list comprehension but returns a generator object.
- More memory-efficient as it generates values on demand.

---

### **Conclusion:**
Comprehensions in Python provide a concise and efficient way to create data structures. Each type of comprehension serves a different purpose and helps in improving code readability and performance.







## **8. Operators in Python**

1. ### What are Python operators? List different types
    ### Python Operators and Their Types
    #### What are Python Operators?
    Operators in Python are special symbols that perform operations on variables and values. They help in performing arithmetic, logical, comparison, bitwise, assignment, and other operations.
    ### Types of Operators in Python

    | **Operator Type**              | **Description**                                  | **Example**                  |
    |--------------------------------|--------------------------------------------------|------------------------------|
    | **1. Arithmetic Operators**    | Perform mathematical operations.                | `+, -, *, /, %, **, //`      |
    | **2. Comparison Operators**    | Compare values and return boolean results.      | `==, !=, >, <, >=, <=`       |
    | **3. Logical Operators**       | Perform logical operations.                     | `and, or, not`               |
    | **4. Assignment Operators**    | Assign values to variables.                     | `=, +=, -=, *=, /=, %=, //=, **=` |
    | **5. Bitwise Operators**       | Perform bitwise operations on binary values.    | `&, |, ^, ~, <<, >>`         |
    | **6. Identity Operators**      | Check whether two variables reference the same object. | `is, is not`                |
    | **7. Membership Operators**    | Check if a value exists in a sequence.          | `in, not in`                 |

    **Examples of Different Operators**
    1. Arithmetic Operators
    ```python
    a = 10
    b = 3
    print(a + b)  # 13
    print(a - b)  # 7
    print(a * b)  # 30
    print(a / b)  # 3.33
    print(a // b) # 3 (Floor division)
    print(a % b)  # 1 (Modulus)
    print(a ** b) # 1000 (Exponentiation)

    ```
    2. Comparison Operators
    ```python
    x = 5
    y = 10
    print(x > y)   # False
    print(x <= y)  # True
    print(x == y)  # False
    print(x != y)  # True
    ```
    3. Logical Operators

    ```python
    a = True
    b = False
    print(a and b)  # False
    print(a or b)   # True
    print(not a)    # False
    ```
    4. Assignment Operators
    ```python
    x = 5
    x += 3  # Same as x = x + 3
    print(x)  # 8
    ```
    5. Bitwise Operators
    ```python
    a = 5  # 101 in binary
    b = 3  # 011 in binary
    print(a & b)  # 1 (Bitwise AND)
    print(a | b)  # 7 (Bitwise OR)
    print(a ^ b)  # 6 (Bitwise XOR)
    print(~a)     # -6 (Bitwise NOT)
    ```
    6. Identity Operators
    ```python
    a = [1, 2, 3]
    b = a
    c = [1, 2, 3]

    print(a is b)  # True (Same object in memory)
    print(a is c)  # False (Different objects with same values)
    print(a is not c)  # True
    ```
    7. Membership Operators
    ```python
    text = "Hello World"
    print("H" in text)      # True
    print("hello" not in text)  # True
    ```
    **Key Takeaways**
    Operators are symbols used for performing operations on variables and values.

    Different types include arithmetic, comparison, logical, assignment, bitwise, identity, and membership operators.

    Operators help in mathematical calculations, decision-making, and data manipulation.




## **9. Conditional Statements**



1. ### What are conditional statements in Python

    ### **Conditional Statements in Python**

    Conditional statements in Python allow the execution of different blocks of code based on specified conditions. They control the flow of execution depending on whether a condition evaluates to `True` or `False`.

    ---

    ### **Types of Conditional Statements in Python**

    | **Statement**    | **Description**  | **Syntax & Example**  |
    |-----------------|----------------|----------------------|
    | `if`            | Executes a block of code only if the condition is `True`. | ```python age = 18 if age >= 18:     print("You are an adult.") # Output: You are an adult.``` |
    | `if-else`       | Executes one block of code if the condition is `True`, otherwise executes another block. | ```python num = 10 if num % 2 == 0:     print("Even number") else:     print("Odd number") # Output: Even number``` |
    | `if-elif-else`  | Checks multiple conditions in sequence. Executes the first `True` condition and skips the rest. | ```python score = 85 if score >= 90:     print("Grade A") elif score >= 75:     print("Grade B") else:     print("Grade C") # Output: Grade B``` |
    | **Nested if**   | An `if` statement inside another `if` statement. | ```python num = 10 if num > 0:     if num % 2 == 0:         print("Positive even number") # Output: Positive even number``` |
    | **Ternary Operator (`if` in one line)** | A shorthand way to write an `if-else` condition. | ```python num = 5 result = "Even" if num % 2 == 0 else "Odd" print(result) # Output: Odd``` |

    ---

    ### **Key Points**
    - Conditional statements use indentation to define blocks of code.
    - `if`, `if-else`, and `if-elif-else` allow different execution paths.
    - The ternary operator is useful for concise conditions.




## **10. Loops in Python**



1. ### What are loops in Python? Why are they used


    ### **What Are Loops?**
    Loops in Python are control flow statements that allow code to be executed repeatedly. They help in automating repetitive tasks by executing a block of code multiple times.

    ### **Why Are Loops Used?**
    Loops are used to:
    - **Reduce Code Repetition**: Avoid writing the same code multiple times.
    - **Iterate Over Data Structures**: Process lists, tuples, dictionaries, etc.
    - **Automate Repetitive Tasks**: Execute operations like counting, searching, or modifying elements.
    - **Improve Code Efficiency**: Handle large datasets without manually coding each step.

    ### **Types of Loops in Python**
    Python has two main types of loops:

    ### **1. `for` Loop**
    Used for iterating over a sequence (list, tuple, string, dictionary, etc.).

    **Example:**
    ```python
    fruits = ["apple", "banana", "cherry"]
    for fruit in fruits:
        print(fruit)
    ```

    **Output:**

    ```
    apple
    banana
    cherry
    ```

    ### 2.**`while` Loop in Python**

    ### **Definition**
    The `while` loop executes a block of code as long as a specified condition remains `True`.

    ### **Example**
    ```python
    count = 1
    while count <= 3:
        print(count)
        count += 1
    ```
    **Output**
    ```
    1
    2
    3
    ```
    **Key Takeaways**
    ‚úÖ Loops reduce redundancy and make code efficient.
    ‚úÖ for loops are best for iterating over sequences.
    ‚úÖ while loops are useful when the number of iterations is unknown.




## **11. Functions in Python**



1. ### What is a function in Python? How do you define one
    ### What is a Function in Python?
    A function in Python is a reusable block of code that performs a specific task. Functions help in organizing and structuring code, making it more modular, readable, and maintainable.

    ### How to Define a Function in Python?
    A function is defined using the def keyword, followed by the function name and parentheses () containing optional parameters. The function body contains the logic and is indented.

    ```python
    def function_name(parameters):
        """Optional docstring"""
        # Function body
        return result  # (Optional) returns a value
    ```
    Example:
    ```python
    def greet(name):
        """Function to greet the user."""
        return f"Hello, {name}!"


    # Calling the function

    print(greet("Alice"))
    ```
    **Output:**
    ```
    Hello, Alice!
    ```

    **Key Points:**
    * ‚úÖ Functions help avoid redundant code and improve reusability.
    * ‚úÖ They can take arguments and return values.
    * ‚úÖ Functions can have default parameters, variable-length arguments, and keyword arguments.
    * ‚úÖ A function without a return statement returns None by default.



2. ### What are `*args` and `**kwargs` in Python

    ### **`*args` and `**kwargs` in Python**

    In Python, `*args` and `**kwargs` are used to pass a variable number of arguments to a function.  

    - `*args` collects multiple **positional arguments** into a tuple.  
    - `**kwargs` collects multiple **keyword arguments** into a dictionary.  

    ---

    ### **üîπ `*args`: Variable Number of Positional Arguments**  
    ### **How It Works:**  
    - The `*args` syntax allows a function to accept any number of positional arguments.
    - These arguments are stored as a **tuple** inside the function.

    ### **Use-Case:**  
    - When the number of arguments needed is **uncertain**.

    ### **Example:**  
    ```python
    def sum_all(*args):
        result = 0
        for num in args:
            result += num
        return result

    print(sum_all(1, 2, 3, 4))  # Output: 10


3. ### What is lambda function

    **Lambda** is an **anonymous function** in Python, that can accept any number of arguments, but can only have a single expression. It is generally used in situations requiring an anonymous function for a short time period. 

    **Lambda functions can be used in either of the two ways:**

    **‚Ä¢ Assigning lambda functions to a variable:**
    ```python 
    mul = lambdaa, b : a * b
    print(mul(2, 5))    # output => 10
    ```
    **‚Ä¢ Wrapping lambda functions inside another function:** 
    ```python
    defmyWrapper(n):
    returnlambdaa : a * n
    mulFive = myWrapper(5)
    print(mulFive(2))    # output => 10
    ```


4. ### What is the enumerate function in Python

    ### **Introduction**
    The `enumerate()` function in Python is used to add a counter to an iterable and return it as an enumerate object. This is particularly useful when looping through a sequence while keeping track of the index.

    ---

    ### **Syntax**
    ```python
    enumerate(iterable, start=0)
    ```
    - **iterable**: The sequence (e.g., list, tuple, string, etc.) to be enumerated.
    - **start**: The starting index for the counter (default is `0`).

    ---

    ### **Example Usage**
    #### **Basic Usage**
    ```python
    fruits = ["apple", "banana", "cherry"]
    for index, fruit in enumerate(fruits):
        print(index, fruit)
    ```
    #### **Output:**
    ```
    0 apple
    1 banana
    2 cherry
    ```

    ---

    ### **Using enumerate() with a Custom Start Index**
    ```python
    fruits = ["apple", "banana", "cherry"]
    for index, fruit in enumerate(fruits, start=1):
        print(index, fruit)
    ```
    #### **Output:**
    ```
    1 apple
    2 banana
    3 cherry
    ```

    ---

    ### **Using enumerate() with List Comprehension**
    ```python
    fruits = ["apple", "banana", "cherry"]
    enum_list = [(i, fruit) for i, fruit in enumerate(fruits)]
    print(enum_list)
    ```
    #### **Output:**
    ```
    [(0, 'apple'), (1, 'banana'), (2, 'cherry')]
    ```

    ---

    ### **Benefits of enumerate()**
    1. **Avoids Manual Indexing:** Eliminates the need to use a separate counter variable.
    2. **Enhances Code Readability:** Cleaner syntax compared to using `range(len(iterable))`.
    3. **Useful in Various Iterations:** Works with lists, tuples, strings, and dictionaries.

    ---

    ### **Conclusion**
    The `enumerate()` function is a powerful tool that improves the efficiency and readability of loops in Python. It simplifies the process of iterating while keeping track of index positions.


5. ### What are higher-order functions in Python
    A **higher-order function** is a function that either:
    - Takes one or more functions as arguments, or
    - Returns a function as its result.

    This concept allows functions to be passed around and used as arguments just like any other object (string, int, float, list, etc).

    ---

    ### Key Features
    - Functions are treated as first-class objects.
    - You can assign them to variables, store them in data structures, pass them as arguments, or return them from other functions.

    ---

    ### Example 1: Function as Argument
    ```python
    # Higher-order function: takes another function as an argument
    def apply_func(func, value):
        return func(value)

    # A simple function
    def square(x):
        return x * x

    result = apply_func(square, 5)
    print(result)  # Output: 25
    ```

    ---

    ### Example 2: Returning a Function
    ```python
    def outer_function(msg):
        def inner_function():
            print("Message:", msg)
        return inner_function

    func = outer_function("Hello")
    func()  # Output: Message: Hello
    ```

    ---

    ### Common Built-in Higher-Order Functions in Python
    - `map()` ‚Äì Applies a function to all items in an iterable.
    - `filter()` ‚Äì Filters items in an iterable based on a condition.
    - `reduce()` ‚Äì Applies a rolling computation to sequential pairs (from `functools`).

    **Example using map():**
    ```python
    numbers = [1, 2, 3, 4, 5]
    squared = list(map(lambda x: x**2, numbers))
    print(squared)  # Output: [1, 4, 9, 16, 25]
    ```

    ---

    ### Summary
    | Concept | Description |
    |--------|-------------|
    | Higher-Order Function | A function that takes or returns another function |
    | Advantage | Enables functional programming style in Python |

    Higher-order functions make your code more modular, concise, and expressive.

6. ### What is the use of the reduce function

    The `reduce()` function is used to apply a rolling computation to sequential pairs of values in an iterable. It is part of the `functools` module in Python and is commonly used to perform cumulative operations such as summing or multiplying a list of values.


    ### Syntax
    ```python
    from functools import reduce
    reduce(function, iterable[, initializer])
    ```

    - **function**: A function that takes two arguments.
    - **iterable**: The iterable whose items will be passed to the function.
    - **initializer** (optional): A value that is used as the initial accumulator.

    ---

    ### Example 1: Product of All Elements
    ```python
    from functools import reduce
    numbers = [1, 2, 3, 4]
    product = reduce(lambda x, y: x * y, numbers)
    print(product)  # Output: 24
    ```

    ### Example 2: Sum with Initial Value
    ```python
    from functools import reduce
    numbers = [1, 2, 3, 4]
    total = reduce(lambda x, y: x + y, numbers, 10)
    print(total)  # Output: 20
    ```

    ---

    ### Key Points
    - Performs cumulative computation like a loop.
    - Returns a **single value**.
    - Requires importing from `functools`.
    - Can use with `lambda` or custom functions.

    ---

    ### Use Cases
    - Calculating factorial
    - Accumulating total cost
    - Reducing a list to a string (e.g., concatenation)

    ---

    ### When Not to Use `reduce()`
    Although powerful, `reduce()` may not always be the most readable option. In many cases, a simple loop or built-in function like `sum()` is preferred for clarity.

    ---

    ### Summary
    - `reduce()` is useful for performing operations that combine all elements in an iterable into a single result.
    - Must be imported from `functools`.
    - Offers a functional way of coding accumulative logic.

7. ### What is a function decorator


    A **function decorator** in Python is a design pattern that allows the modification or enhancement of a function's behavior without changing its source code. Decorators are commonly used for logging, enforcing access control, instrumentation, caching, and more.

    ---

    ### Syntax
    ```python
    @decorator_name
    def function_name():
        # function body
    ```
    This is equivalent to:
    ```python
    def function_name():
        # function body

    function_name = decorator_name(function_name)
    ```

    ---

    ### Basic Example
    ```python
    def my_decorator(func):
        def wrapper():
            print("Something is happening before the function is called.")
            func()
            print("Something is happening after the function is called.")
        return wrapper

    @my_decorator
    def say_hello():
        print("Hello!")

    say_hello()
    ```
    **Output:**
    ```
    Something is happening before the function is called.
    Hello!
    Something is happening after the function is called.
    ```

    ---

    ### Example with Arguments
    ```python
    def my_decorator(func):
        def wrapper(*args, **kwargs):
            print("Before function call")
            result = func(*args, **kwargs)
            print("After function call")
            return result
        return wrapper

    @my_decorator
    def greet(name):
        print(f"Hello, {name}!")

    greet("Alice")
    ```

    ---

    ### Built-in Decorators
    - `@staticmethod`
    - `@classmethod`
    - `@property`

    ---

    ### Use Cases
    - Logging
    - Authentication
    - Measuring performance
    - Caching results

    ---

    ### Summary
    - Decorators wrap a function and allow pre- or post-processing.
    - Use `@decorator` syntax for cleaner and readable code.
    - Highly useful for reusable and modular enhancements.

8. ### What is a Class Decorator

    A **class decorator** is a special type of decorator in Python that is used to modify or enhance classes. Like function decorators, class decorators are applied using the `@decorator_name` syntax and can add or override class attributes, modify methods, or even replace the entire class.

    ---

    ### Syntax
    ```python
    @decorator_name
    class ClassName:
        # class body
    ```
    This is equivalent to:
    ```python
    class ClassName:
        # class body

    ClassName = decorator_name(ClassName)
    ```

    ---

    ### Basic Example
    ```python
    def my_class_decorator(cls):
        class WrappedClass(cls):
            def new_method(self):
                return "This is a new method added by the decorator."
        return WrappedClass

    @my_class_decorator
    class MyClass:
        def original_method(self):
            return "This is the original method."

    obj = MyClass()
    print(obj.original_method())
    print(obj.new_method())
    ```

    **Output:**
    ```
    This is the original method.
    This is a new method added by the decorator.
    ```

    ---

    ### Use Cases
    - Adding or modifying methods or attributes
    - Injecting behavior without modifying the original class
    - Validation and input checking
    - Logging and monitoring class activity

    ---

    ### Summary
    - Class decorators wrap an entire class, not just a method or function.
    - They are useful for applying cross-cutting concerns like logging or monitoring.
    - They return either the modified class or a completely new one.

9. ### What is the purpose of the property decorator


    The `@property` decorator in Python is used to define a method as a **read-only property**. It allows you to access a method like an attribute, enabling controlled access to instance data. This is part of Python's support for **encapsulation** and cleaner interfaces.

    ---

    ### Syntax
    ```python
    class ClassName:
        def __init__(self, value):
            self._value = value

        @property
        def value(self):
            return self._value
    ```

    In this example, `value()` is accessed like an attribute, not a method.

    ---

    ### Example
    ```python
    class Circle:
        def __init__(self, radius):
            self._radius = radius

        @property
        def radius(self):
            return self._radius

        @property
        def area(self):
            from math import pi
            return pi * self._radius ** 2

    c = Circle(5)
    print(c.radius)  # Access without parentheses
    print(c.area)
    ```

    **Output:**
    ```
    5
    78.53981633974483
    ```

    ---

    ### Use Cases
    - Making a method act like a read-only attribute
    - Encapsulation without breaking the interface
    - Computed properties (e.g., area based on radius)

    ---

    ### Additional: Setter and Deleter
    You can also define setters and deleters using the same property name:

    ```python
    class Person:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        @name.setter
        def name(self, value):
            if not value:
                raise ValueError("Name cannot be empty")
            self._name = value

        @name.deleter
        def name(self):
            del self._name
    ```

    ---

    ### Summary
    - `@property` turns a method into a read-only attribute.
    - You can define getter, setter, and deleter using `@property`, `@<prop>.setter`, and `@<prop>.deleter`.
    - Useful for creating clean APIs with encapsulated data.



## **12. Iterators and Generators**



1. ### What is an iterator in Python
    ### **Iterator in Python**

    An **iterator** is an object that allows you to traverse through all the elements of a collection (like a **list** or **tuple**) one by one.

    It follows the **iterator protocol**, which consists of the methods:
    - `__iter__()` ‚Äì Returns the iterator object itself.
    - `__next__()` ‚Äì Returns the next value from the iterator. If there are no more items, it raises a **StopIteration** exception.

    ---

    ### **How Iterators Work**
    An object is considered an **iterator** if it has both `__iter__()` and `__next__()` methods.

    üîπ **Iterators are lazy** ‚Äì they generate values **one at a time** as needed, which makes them **memory efficient**.

    ---

    ### **Example of an Iterator**

    ### **Creating an iterator from a list**
    ```python
    numbers = [1, 2, 3, 4]
    iterator = iter(numbers)  # Get an iterator object

    print(next(iterator))  # Output: 1
    print(next(iterator))  # Output: 2
    print(next(iterator))  # Output: 3
    print(next(iterator))  # Output: 4

    # next(iterator)  # Raises StopIteration as there are no more elements
    ```
    ### **Using a Custom Iterator**
    ```python
    class Counter:
        def __init__(self, limit):
            self.limit = limit
            self.count = 0

        def __iter__(self):
            return self

        def __next__(self):
            if self.count < self.limit:
                self.count += 1
                return self.count
            else:
                raise StopIteration

    counter = Counter(3)

    for num in counter:
        print(num)  # Output: 1, 2, 3
    ```

    Here is the difference between Iterator and Iterable in Markdown table format:
    | Feature        | Iterable | Iterator |
    |--------------|----------|----------|
    | **Definition** | Any object that can return an iterator. | An object that represents a stream of data. |
    | **Implementation** | Implemented with `__iter__()` method. | Implemented with both `__iter__()` and `__next__()` methods. |
    | **Examples** | Lists, Tuples, Strings, Sets, Dictionaries. | Custom objects that implement iterator methods. |
    | **Resetting** | Can be iterated multiple times (by creating new iterators). | Can be **exhausted** (i.e., once traversed, it cannot be reset). |

2. ### What are generators? How do they work

    ### **Generators in Python**
    A generator is a special type of iterator that allows you to iterate over a sequence of values lazily, meaning they generate values one at a time as needed, instead of storing them in memory. Generators are defined using functions and the yield keyword.

    ### **How Generators Work**
    1. Defined like a normal function but instead of return, they use yield to produce values.

    1. State is maintained between function calls, meaning local variables persist across executions.

    2. Memory Efficient because they don‚Äôt store all values in memory at once.

    3. Used for large datasets or infinite sequences where storing all values would be inefficient.

    ### **Example: Simple Generator**
    ```python
    def count_up_to(n):
        count = 1
        while count <= n:
            yield count  # Produces a value
            count += 1

    # Using the generator
    gen = count_up_to(5)

    print(next(gen))  # Output: 1
    print(next(gen))  # Output: 2
    print(next(gen))  # Output: 3
    ```
    **Key Differences: Generator vs Normal Function**
    | Feature           | Normal Function | Generator |
    |------------------|----------------|-----------|
    | **Returns**      | Returns a value and terminates | Uses `yield` to produce multiple values |
    | **Memory Usage** | Stores all values in memory | Generates values one by one (lazy evaluation) |
    | **State Retention** | No state is retained between calls | State is preserved between `yield` calls |
    | **Iteration**    | Called once and stops | Can be iterated multiple times using `next()` |
    ---




    ## **13. Exception Handling in Python**

1. ### What is exception handling in Python  
    ### **Exception Handling in Python**
    **Definition**
    Exception handling in Python is a mechanism that allows a program to handle runtime errors gracefully, preventing crashes and ensuring smooth execution. It is done using try, except, finally, and else blocks.

    **Why is Exception Handling Important?**
    * Prevents program crashes due to unexpected errors.

    * Helps in debugging by providing error messages.

    * Ensures smooth execution by handling known and unknown errors.

    **Basic Syntax**
    ```python
    try:
        # Code that may cause an exception
        num = int(input("Enter a number: "))
        print(10 / num)  # May cause ZeroDivisionError
    except ZeroDivisionError:
        print("Cannot divide by zero!")
    except ValueError:
        print("Invalid input! Please enter a number.")
    finally:
        print("Execution completed.")
    ```
    | Keyword   | Description |
    |-----------|------------|
    | `try`     | Defines a block of code to test for errors. |
    | `except`  | Defines a block of code to handle specific errors. |
    | `finally` | Executes a block of code, whether an error occurs or not. |
    | `else`    | Executes if no exception occurs in the `try` block. |

2. ### What is the difference between syntax errors and runtime errors  
    ### Difference between Syntax Errors and Runtime Errors


    | **Feature**       | **Syntax Error**                                     | **Runtime Error**                                    |
    |------------------|------------------------------------------------|-------------------------------------------------|
    | **Definition**   | Errors due to incorrect syntax in the code. | Errors that occur while the program is running. |
    | **When it Occurs** | During the compilation or parsing of code before execution. | During the execution of a program. |
    | **Cause**        | Incorrect indentation, missing colons, incorrect keywords, etc. | Division by zero, accessing undefined variables, type mismatches, etc. |
    | **Detection**    | Detected before the program runs (at compile-time). | Detected only when the specific line is executed. |
    | **Fixing**       | Correcting the syntax according to Python rules. | Handling exceptions using `try-except` blocks. |
    | **Example**      | `print "Hello"` (Missing parentheses in Python 3) | `x = 1 / 0` (ZeroDivisionError) |


    ### **Example Usage**

    #### **Syntax Error Example**
    ```python
    # Missing parentheses in Python 3
    print "Hello, World!"  # SyntaxError: Missing parentheses
    ```

    #### **Runtime Error Example**
    ```python
    x = 10
    y = 0
    print(x / y)  # ZeroDivisionError: division by zero
    ```

    ### **Key Takeaways:**
    - **Syntax errors** prevent the code from running and must be fixed before execution.
    - **Runtime errors** occur during execution and can often be handled using exception handling (`try-except`).
    - Syntax errors are easy to detect as they appear before execution, while runtime errors depend on the program's flow.

3. ### What are built-in exceptions in Python  
    ### Built-in Exceptions in Python

    Python provides several built-in exceptions to handle various runtime errors. These exceptions help identify errors and manage them using exception handling mechanisms.


    | **Exception**      | **Description** |
    |------------------|------------------------------------------------|
    | `SyntaxError`    | Raised when there is a syntax mistake in the code. |
    | `IndentationError` | Raised when incorrect indentation is used. |
    | `TypeError`      | Raised when an operation is applied to an object of an inappropriate type. |
    | `ValueError`     | Raised when a function receives an argument of the correct type but with an invalid value. |
    | `IndexError`     | Raised when trying to access an index that is out of range in a list or tuple. |
    | `KeyError`       | Raised when trying to access a non-existent key in a dictionary. |
    | `NameError`      | Raised when a variable is referenced before being defined. |
    | `AttributeError` | Raised when an invalid attribute is accessed in an object. |
    | `ZeroDivisionError` | Raised when division by zero occurs. |
    | `FileNotFoundError` | Raised when a file operation (e.g., open) fails due to a missing file. |
    | `MemoryError`    | Raised when an operation runs out of memory. |
    | `RuntimeError`   | Raised when an error is detected but doesn't fall into any other category. |
    | `StopIteration`  | Raised when the `next()` function reaches the end of an iterator. |
    | `GeneratorExit`  | Raised when a generator is closed using the `close()` method. |
    | `ImportError`    | Raised when an import statement fails to find the module. |
    | `ModuleNotFoundError` | Raised when a specified module cannot be found. |
   
   


    ### **Example Usage**

    #### **Handling `ZeroDivisionError`**
    ```python
    try:
        result = 10 / 0
    except ZeroDivisionError as e:
        print("Error:", e)
    ```

    #### **Handling `KeyError`**
    ```python
    data = {"name": "Alice"}
    try:
        print(data["age"])  # KeyError: 'age' does not exist
    except KeyError as e:
        print("Key not found:", e)
    ```

    #### **Handling `FileNotFoundError`**
    ```python
    try:
        with open("nonexistent.txt", "r") as file:
            content = file.read()
    except FileNotFoundError as e:
        print("File error:", e)
    ```

    ### **Key Takeaways:**
    - Built-in exceptions help identify common runtime errors in Python.
    - Exception handling using `try-except` can prevent crashes and provide better error messages.
    - Understanding these exceptions helps in writing robust and error-free code.

4. ### What is the purpose of try, except, and finally blocks  
    #### Purpose of Try, Except, and Finally Blocks

    Python provides `try`, `except`, and `finally` blocks to handle exceptions and ensure smooth execution of code.


    | **Block**   | **Purpose** |
    |------------|------------------------------------------------|
    | `try`      | Defines a block of code to be tested for errors. If an error occurs, it is passed to the `except` block. |
    | `except`   | Catches and handles exceptions that occur in the `try` block. Specific exceptions can be handled separately. |
    | `finally`  | Executes code regardless of whether an exception occurs or not. Used for cleanup operations like closing files or releasing resources. |


    ### **Example Usage**

    #### **Basic Exception Handling with `try` and `except`**
    ```python
    try:
        x = 10 / 0
    except ZeroDivisionError:
        print("Cannot divide by zero!")
    ```

    #### **Handling Multiple Exceptions**
    ```python
    try:
        num = int("abc")
    except ValueError:
        print("Invalid input: Expected a number")
    ```

    #### **Using `finally` for Cleanup**
    ```python
    try:
        file = open("example.txt", "r")
        content = file.read()
    except FileNotFoundError:
        print("File not found!")
    finally:
        print("Closing file...")
        file.close()
    ```

    ### **Key Takeaways:**
    - `try` blocks contain code that may cause an exception.
    - `except` blocks handle specific or general exceptions.
    - `finally` blocks execute code regardless of exception occurrence, ensuring cleanup operations are performed.
    - Exception handling prevents program crashes and improves robustness.

5. ### How can you raise an exception in Python  

    ### Raising Exceptions in Python

    ### **What is an Exception?**
    An exception is an error that occurs during the execution of a program. In Python, exceptions can be handled using `try-except` blocks. However, sometimes you may need to raise an exception manually to indicate an error condition or enforce constraints. This is where the `raise` keyword comes into play.

    ### **Using the `raise` Keyword**
    Python provides the `raise` statement to trigger exceptions explicitly. This can be useful in various scenarios such as input validation, enforcing business logic, and debugging.

    ### **Methods to Raise Exceptions**
    ```markdown
    | **Method**                  | **Description** |
    |----------------------------|------------------------------------------------|
    | `raise Exception`           | Raises a built-in or custom exception manually. |
    | `raise Exception("message")` | Raises an exception with a custom error message. |
    | `raise` (inside `except`)   | Re-raises the caught exception. |
    ```

    ### **Examples of Raising Exceptions**

    #### **1. Raising a Built-in Exception**
    ```python
    x = -5
    if x < 0:
        raise ValueError("Negative values are not allowed!")
    ```
    **Explanation:**
    - Here, we check if `x` is negative.
    - If the condition is met, we explicitly raise a `ValueError` with a custom error message.

    #### **2. Raising a Custom Exception**
    Python allows you to create custom exceptions by defining a new class that inherits from `Exception`.
    ```python
    class CustomError(Exception):
        def __init__(self, message):
            super().__init__(message)

    raise CustomError("This is a custom exception!")
    ```
    **Explanation:**
    - A new class `CustomError` is created, inheriting from `Exception`.
    - When `raise CustomError("message")` is called, it triggers our custom exception.

    #### **3. Re-raising an Exception**
    Sometimes, you may want to catch an exception, log it, and then re-raise it.
    ```python
    try:
        x = 10 / 0
    except ZeroDivisionError as e:
        print("Caught an error:", e)
        raise  # Re-raises the same exception
    ```
    **Explanation:**
    - The `try` block attempts to divide by zero, which raises a `ZeroDivisionError`.
    - The `except` block catches the error and prints a message.
    - The `raise` statement (without arguments) re-raises the same exception for further handling.

    ### **Handling Raised Exceptions**
    If you raise an exception in your code, you can handle it using `try-except` blocks:
    ```python
    try:
        raise ValueError("Invalid input detected!")
    except ValueError as e:
        print("Caught Exception:", e)
    ```

    ### **Key Takeaways:**
    - `raise` is used to manually trigger exceptions.
    - You can provide a custom error message when raising exceptions.
    - Custom exceptions can be created by inheriting from the `Exception` class.
    - The `raise` statement inside an `except` block can re-throw the current exception.
    - Raising exceptions is useful for enforcing rules and making code more robust.

    Using exception handling properly can make your Python programs more reliable and easier to debug.





## **15. Modules and Packages**  

1. ### What is a module in Python  
    In Python, a **module** is a file containing Python definitions and statements, including functions, classes, and variables, that can be imported and used in other Python programs. It allows you to organize your code logically and reuse it across different projects.

    A module can be a single Python file (with a` .py `extension) or a directory containing multiple Python files and a special file called `__init__.py.`

    #### **How to Use a Module:**
    To use a module in Python, you can import it using the import statement.

    **Example:**

    ```python
    # Importing a module
    import math

    # Using a function from the math module
    print(math.sqrt(16))  # Output: 4.0
    ```
    **Types of Modules:**
    * Built-in modules: Python comes with many built-in modules, like math, os, sys, etc.

    * Third-party modules: These are external modules, often installed using pip (Python's package installer), like numpy, pandas, etc.

    * Custom modules: You can create your own modules by saving Python code in a .py file and importing it.

    **Example of a custom module:**

    i. Create a file named mymodule.py:

    ```python
    # mymodule.py
    def greet(name):
        print(f"Hello, {name}!")
    ```
    ii. In another Python file, you can import and use the custom module:

    ```python
    import mymodule

    mymodule.greet("Alice")  # Output: Hello, Alice!
    ```
    #### **Benefits of Modules:**
    **Code Reusability:** You can write a module once and reuse it in multiple programs.

    **Namespace organization:** Modules help avoid naming conflicts by organizing code into separate namespaces.

    **Maintainability:** It‚Äôs easier to manage and maintain code in smaller, modular pieces rather than in a single large file.

2. ### What is the difference between a module and a package  
    Python packages and Python modules are two mechanisms that allow for modular programming in Python. Modularizing has several advantages

    ‚Ä¢ **Simplicity:** Working on a single module helps you focus on a relatively small portion of the problem at hand. This makes development easier and less error-prone.

    ‚Ä¢ **Maintainability:** Modules are designed to enforce logical boundaries between different problem domains. If they are written in a manner that reduces interdependency, it is less likely that modifications in a module might impact other parts of the program.

    ‚Ä¢ **Reusability:** Functions defined in a module can be easily reused by other parts of the application.

    ‚Ä¢ **Scoping:** Modules typically define a separate namespace, which helps avoid confusion between identifiers from other parts of the program.

    **Modules,** in general, are simply Python files with a .py extension and can have a set of functions, classes, or variables defined and implemented. They can be imported and initialized once using the import statement. If partial functionality is needed, import the requisite classes or functions using from foo import bar.

    **Packages** allow for hierarchial structuring of the module namespace using dot notation. As, modules help avoid clashes between global variable names, in a similar manner, packages help avoid clashes between module names.
    Creating a package is easy since it makes use of the system's inherent file structure. So just stuff the modules into a folder and there you have it, the folder name as the package name. Importing a module or its contents from this package requires the package name as prefix to the module name joined by a dot.

    **Note:** You can technically import the package as well, but alas, it doesn't import the modules within the package to the local namespace, thus, it is practically useless.

3. ### How can you import module state different types?
    ### üìò Python `import` Syntax Guide

    ### ‚úÖ Fixed `import` Syntax

    The syntax for importing **does not change**, but how you **use** the imported item depends on what you're importing.

    ---

    ### üîπ 1. Importing a Function

    ```python
    from mymodule import myfunction

    myfunction()
    ```

    ### üîπ 2. Importing a Class
    ```python
    from mymodule import MyClass

    obj = MyClass()
    obj.method()
    ```


    ### üîπ 3. Importing Multiple Items
    ```python
    from mymodule import func1, func2, MyClass

    ```

    ### üîπ 4. Using an Alias (Nickname)
    ```python
    from mymodule import myfunction as mf

    mf()

    ```

    ### üîπ 5. Importing the Whole Module

    ```python
    import mymodule

    mymodule.myfunction()
    mymodule.MyClass()


    ```

    | What You're Importing | Syntax                       | How You Use It                     |
    | --------------------- | ---------------------------- | ---------------------------------- |
    | Function              | `from mod import func`       | `func()`                           |
    | Class                 | `from mod import MyClass`    | `obj = MyClass()` ‚Üí `obj.method()` |
    | Entire Module         | `import mod`                 | `mod.func()`, `mod.MyClass()`      |
    | Multiple Items        | `from mod import A, B`       | `A()`, `B()`                       |
    | Alias                 | `from mod import A as alias` | `alias()`                          |

4. ### Why Do We Use Modules and Packages?
    üîπ 1. Organization
    Split code into files/folders so it‚Äôs not one big mess.

    ‚úÖ You don‚Äôt want 1000 lines in one file. Break it down logically ‚Äî utils, models, views, etc.

    üîπ 2. Reusability
    Write once, use everywhere.

    ‚úÖ You can import the same functions/classes in other projects.

    üîπ 3. Maintainability
    If something breaks, you know where to fix it ‚Äî it‚Äôs modular.

    ‚úÖ Easier to test, debug, and upgrade parts.

    üîπ 4. Team Collaboration
    Everyone can work on different modules/packages independently.

    ‚úÖ You handle auth.py, someone else handles db.py, no conflicts.

    #### üß† Bottom Line:
    - Modules = 1 .py file
    - Packages = Multiple modules in a folder with `__init__.py`


2. ### What is the difference between a module and a package  

    ### üîπ What is a Module?
    - A **module** is just a **single `.py` file**.
    - It can contain **functions, variables, and classes**.

    **Example:**
    ```python
    # file: math_utils.py
    def add(a, b):
        return a + b
    ```
    **Usage:**
    ```python
    from math_utils import add
    print(add(2, 3))  # Output: 5
    ```

    ### üîπ What is a Package?
    - A package is a folder that contains one or more modules.

    - It must have a special `__init__.py` file (can be empty).

    - You can organize related modules together.
    ### Folder structure:
    ```
    mypackage/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ math_utils.py
    ‚îî‚îÄ‚îÄ string_utils.py
    ```
    **Usage:**
    ```python
    from mypackage.math_utils import add
    ```
    **Importing a package alone won‚Äôt give you access to its modules directly.**
    ```python
    from mypackage import math_utils
    ```

    **Why use them**
    | Feature         | Module                   | Package                            |
    | --------------- | ------------------------ | ---------------------------------- |
    | Simplicity      | Small, focused file      | Organizes multiple related modules |
    | Maintainability | Easier to edit and debug | Keeps things clean and separated   |
    | Reusability     | Import functions easily  | Share/reuse entire codebase        |
    | Scoping         | Avoids name clashes      | Same benefit on a larger scale     |
        

---

## **16. Object-Oriented Programming (OOP) in Python**



1. ### What is a class in Python

    In Python, a `class` is a blueprint for creating objects (instances). It defines a set of attributes (variables) and methods (functions) that describe the behavior of the objects created from the class.

    **Key Components of a Class:**
    **Attributes (or properties):** Variables that store information related to the class or its instances.

    **Methods:** Functions defined within a class that describe the actions or behavior of an object.

    Constructor (`__init__` method): A special method that is called when an object is created. It initializes the object's attributes.

    **Basic Structure of a Class:**
    Here‚Äôs a simple example of how to define a class in Python:

    ```python
    class Dog:
        # Constructor method to initialize an instance of the class
        def __init__(self, name, age):
            self.name = name  # Instance variable
            self.age = age    # Instance variable

        # Method to describe the dog
        def bark(self):
            print(f"{self.name} says woof!")

        # Method to get the dog's age
        def get_age(self):
            return self.age

    # Creating an instance (object) of the Dog class
    my_dog = Dog("Buddy", 5)

    # Accessing attributes and methods
    print(my_dog.name)  # Output: Buddy
    print(my_dog.age)   # Output: 5
    my_dog.bark()       # Output: Buddy says woof!
    ```
    **Explanation of the Example:**
    `class Dog:` defines a class named `Dog.`

    `__init__`(self, name, age): is the constructor that initializes the `name` and `age` attributes of the object.

    `self.name` and `self.age` are instance variables that store information specific to each object.

    `bark(self)` and `get_age(self)` are methods that provide behavior for the class.

    `my_dog` = `Dog("Buddy", 5)` creates an instance of the class Dog, and the constructor initializes its attributes with the values `"Buddy"` and `5.`

    **Instantiating a Class:**
    To create an instance of a class (an object), you call the class like a function:
    ```python
    my_dog = Dog("Buddy", 5)
    ```

    **Important Concepts:**
    * **Instance Variables:** These are variables bound to the specific instance of the class. They are usually initialized in the __init__ constructor.

    * **Class Variables:** Variables shared across all instances of a class (not bound to specific instances).

    * **Methods:** Functions defined inside a class to perform operations on the object. They always take at least one argument, self, which refers to the current instance of the class.

    **Example with Class Variables:**
    ```python
    class Dog:
        # Class variable
        species = "Canine"

        def __init__(self, name, age):
            self.name = name
            self.age = age

    # Creating two instances
    dog1 = Dog("Buddy", 3)
    dog2 = Dog("Lucy", 2)

    # Accessing class variable
    print(dog1.species)  # Output: Canine
    print(dog2.species)  # Output: Canine
    ```
    **Inheritance:**
    Classes can also inherit from other classes, meaning they can inherit attributes and methods from a parent class.

    ```python
    class Animal:
        def speak(self):
            print("Animal makes a sound")

    class Dog(Animal):
        def bark(self):
            print("Dog barks")

    dog = Dog()
    dog.speak()  # Output: Animal makes a sound (inherited from Animal class)
    dog.bark()   # Output: Dog barks
    ```
    #### **Benefits of Using Classes:**
    * **Encapsulation:** Group related data and methods together.

    * **Reusability:** You can create multiple instances of a class with different data, making the code more modular and reusable.

    * **Inheritance:** Allows creating new classes based on existing ones, promoting code reuse.


2. ### What is an object in Python
    In Python, an object is an instance of a class. It is a collection of data (attributes) and functions (methods) that operate on the data. Each object has its own set of data, but shares the methods defined in the class.

    **Key Points:**
    * **Instance of a Class:** When you create an object, it‚Äôs an instance of a class. It can access the class‚Äôs attributes and methods.

    * **Attributes**: The data associated with an object (variables). These can be instance variables (specific to an object) or class variables (shared across all instances of the class).

    * **Methods:** Functions that define the behavior of the object.

    **Example:**
    Here‚Äôs an example of a class Dog, and then we create objects (instances) of that class:

    ```python
    class Dog:
        # Constructor method to initialize the object
        def __init__(self, name, age):
            self.name = name  # Attribute of the object
            self.age = age    # Attribute of the object

        # Method of the object
        def bark(self):
            print(f"{self.name} says woof!")

    # Creating objects (instances) of the Dog class
    dog1 = Dog("Buddy", 3)  # Object 1
    dog2 = Dog("Lucy", 2)   # Object 2

    # Accessing attributes and methods of objects
    print(dog1.name)  # Output: Buddy
    print(dog2.age)   # Output: 2
    dog1.bark()       # Output: Buddy says woof!
    dog2.bark()       # Output: Lucy says woof!

    ```
    #### **Breakdown:**
    * `dog1 `and `dog2` are **objects** (or instances) of the `Dog` class.

    * Each object has its own attributes (`name`, `age`), which are initialized when the object is created by calling the class's constructor (`__init__`).

    * The `bark` method is a function that can be called on any object of the `Dog` class.

    #### **Characteristics of Objects:**
    * **Unique Data:** Each object has its own copy of the instance variables. For example, dog1.name might be "Buddy", while dog2.name could be "Lucy", even though both are instances of the same class.

    * **Access to Methods:** Objects can call methods that are defined in their class. These methods can access and modify the attributes of the object

    #### **Why are Objects Important?**
    **Encapsulation:** Objects bundle data (attributes) and behavior (methods) together. This makes your code more modular and organized.

    **Real-world Representation:** Objects allow you to model real-world entities. For example, a `Dog` class can represent real dogs, where each dog has a name, age, and can bark.

    **Reuse:** You can create many objects from a class, each with its own data but using the same methods.

    #### **Example of Multiple Objects:**
    You can create multiple objects (instances) of a class, each having different data, as shown in this example:

    ```python
    class Car:
        def __init__(self, make, model, year):
            self.make = make
            self.model = model
            self.year = year

        def display_info(self):
            print(f"{self.year} {self.make} {self.model}")

    # Creating objects
    car1 = Car("Toyota", "Camry", 2020)
    car2 = Car("Honda", "Civic", 2022)

    # Calling methods on objects
    car1.display_info()  # Output: 2020 Toyota Camry
    car2.display_info()  # Output: 2022 Honda Civic


    ```
    Here, `car1` and `car2` are two separate objects, each with its own data.

3. ### What is the purpose of the `__init__` method

    The `__init__` method in Python is a special method, also known as a **constructor**, that is automatically called when an **object** (instance) of a class is created. Its primary purpose is to initialize the newly created object by setting the initial values for its attributes.

    **Key Points about** `__init__`:
    * **Initialization of Object Attributes:** The `__init__` method allows you to initialize the attributes of the object when it is created.

    * **Self Parameter:** The first parameter of `__init__` is always `self`, which refers to the current instance of the class. It‚Äôs how the method can access and modify the attributes of the object.

    * **No Return Value:** The` __init__` method does not return anything. Its purpose is solely to initialize the object.

    **Example:**
    ```python
    class Dog:
        def __init__(self, name, age):  # Constructor with parameters
            self.name = name  # Initializing object attribute 'name'
            self.age = age    # Initializing object attribute 'age'

        def bark(self):
            print(f"{self.name} says woof!")

    # Creating an object (instance) of the Dog class
    my_dog = Dog("Buddy", 3)

    # Accessing the attributes of the object
    print(my_dog.name)  # Output: Buddy
    print(my_dog.age)   # Output: 3

    # Calling the bark method
    my_dog.bark()       # Output: Buddy says woof!


    ```
    **Explanation:**
    * The `__init__` method is defined to accept parameters `name` and `age` when creating an object of the Dog class.

    * When you create the object `my_dog = Dog("Buddy", 3)`, the `__init__` method is automatically called, and the values `"Buddy"` and `3` are passed to the `name` and `age` parameters respectively.

    * The `self.name` and `self.age` attributes are initialized with these values, allowing the object to store the name and age of the dog.

    **Why is `__init__` important?**
    * **Object Setup:** It ensures that every object of a class starts with the necessary attributes, set to sensible initial values.

    * **Customization:** You can customize how objects of your class are initialized by passing arguments to the `__init__` method.

    * **Encapsulation:** It allows each object to maintain its own state, which is particularly important in object-oriented programming

    **Default Constructor:**
    If you don't define an `__init__` method in your class, Python will provide a default constructor that doesn't do anything. However, defining your own `__init__` method is typically needed to initialize objects with meaningful values.

    Example of a class without an `__init__` method:
    ```python
    class Dog:
        def bark(self):
            print("Woof!")

    # Creating an object
    my_dog = Dog()

    # Since we don't have an `__init__` method, no attributes are set.
    # But we can still call methods like bark.
    my_dog.bark()  # Output: Woof!


    ```

4. ### What are class variables and instance variables
    In Python, class variables and instance variables are two types of variables that serve different purposes in a class. Here's an explanation of each:

    1. **Instance Variables**
    Instance variables are variables that are associated with a specific instance (object) of a class. These variables hold data that is unique to each object. Each object has its own copy of instance variables.

    * **Defined within the**  `__init__` **method** or other methods using `self`.

    * Each object created from the class has its own copy of the instance variable.

    * Instance variables can be modified per object.

    **Example of Instance Variables:**
    ```python
    class Dog:
        def __init__(self, name, age):
            self.name = name  # Instance variable
            self.age = age    # Instance variable

    # Creating objects
    dog1 = Dog("Buddy", 3)
    dog2 = Dog("Lucy", 5)

    # Accessing instance variables
    print(dog1.name)  # Output: Buddy
    print(dog2.name)  # Output: Lucy
    print(dog1.age)   # Output: 3
    print(dog2.age)   # Output: 5

    ```
    In the example above:

    * `name` and `age` are instance variables, as they are set using self and are unique to each object (`dog1` and `dog2`).

    * `dog1.name` is `"Buddy"`, and `dog2.name` is `"Lucy"`. Each dog object has its own `name` and `age `values.

    2.**Class Variables**
    Class variables are variables that are shared across all instances (objects) of a class. They are defined within the class, but **outside of any methods**. All instances of the class share the same class variable, meaning if one instance modifies it, the change is reflected in all other instances.

    * **Defined inside the class** but outside any methods.

    * Shared by all instances of the class.

    * Can be modified using the class name or through any object, but modifying through an object can lead to unexpected behavior.
    **Example of Class Variables:**
    ```python
    class Dog:
        species = "Canine"  # Class variable

        def __init__(self, name, age):
            self.name = name  # Instance variable
            self.age = age    # Instance variable

    # Creating objects
    dog1 = Dog("Buddy", 3)
    dog2 = Dog("Lucy", 5)

    # Accessing class variables
    print(dog1.species)  # Output: Canine
    print(dog2.species)  # Output: Canine
    print(Dog.species)   # Output: Canine

    # Changing class variable through class
    Dog.species = "Feline"
    print(dog1.species)  # Output: Feline
    print(dog2.species)  # Output: Feline

    # Changing class variable through instance (not recommended)
    dog1.species = "Reptile"
    print(dog1.species)  # Output: Reptile (dog1 now has its own species variable)
    print(dog2.species)  # Output: Feline (dog2 still shares the class variable)


    ```

    In this example:

    * `species` is a **class variable** because it's defined at the class level (inside the `Dog` class but outside any methods).

    * All objects, like `dog1` and `dog2`, initially share the same class variable species. If you change `species` via the class (like `Dog.species` = `"Feline"`), the change affects all objects.

    * However, if you change the class variable via an instance (`dog1.species` = `"Reptile"`), it creates a new instance variable for that object, and that instance no longer shares the class variable `species`.


    **Key Differences Between Instance Variables and Class Variables:**
    ### Key Differences Between Instance Variables and Class Variables

    | Feature             | Instance Variables                                   | Class Variables                           |
    |---------------------|------------------------------------------------------|-------------------------------------------|
    | **Scope**           | Unique to each object/instance                       | Shared across all instances of the class |
    | **Definition**      | Defined in the `__init__` method (or other methods)  | Defined at the class level (outside methods) |
    | **Access**          | Accessed using `self` (e.g., `self.name`)            | Accessed using the class name or any instance (e.g., `Dog.species`) |
    | **Modification**    | Can be modified per instance/object                  | Shared across all instances; modifying it changes it for all objects (unless overridden per object) |

    **Example Combining Both:**
    ```python
    class Car:
        wheels = 4  # Class variable (shared by all cars)

        def __init__(self, make, model, year):
            self.make = make  # Instance variable
            self.model = model  # Instance variable
            self.year = year    # Instance variable

        def display_info(self):
            print(f"{self.year} {self.make} {self.model} with {Car.wheels} wheels")

    # Creating instances
    car1 = Car("Toyota", "Corolla", 2020)
    car2 = Car("Honda", "Civic", 2021)

    # Accessing instance and class variables
    car1.display_info()  # Output: 2020 Toyota Corolla with 4 wheels
    car2.display_info()  # Output: 2021 Honda Civic with 4 wheels

    # Changing class variable
    Car.wheels = 6
    car1.display_info()  # Output: 2020 Toyota Corolla with 6 wheels
    car2.display_info()  # Output: 2021 Honda Civic with 6 wheels

    ```
    In this example:

    * `wheels` is a class variable, shared across all Car instances.

    * `make`, `model`, and `year` are instance variables, unique to each car object.

    **Conclusion:**
    * **Instance variables** are used to store data unique to each object created from the class.

    * **Class variables** are shared by all objects of the class and are often used to store data that is common to all instances.
5. ### What is the difference between a class and an object
    The difference between a class and an object can be understood by considering that a class is a blueprint or template, while an object is an instance of that class, created using the blueprint.

    **Key Differences Between a Class and an Object:**
    ### Key Differences Between Class and Object

    | Feature                | **Class**                                  | **Object**                                 |
    |------------------------|--------------------------------------------|--------------------------------------------|
    | **Definition**          | A class is a blueprint or template for creating objects. It defines the structure (attributes) and behaviors (methods) that objects created from it will have. | An object is an instance of a class. It is created from the blueprint (class) and contains specific data (attributes) and methods (behaviors). |
    | **Existence**           | A class is just a definition and does not occupy memory space until objects are created from it. | An object is a concrete instance of a class and occupies memory. |
    | **Creation**            | A class is defined using the `class` keyword. | An object is created by calling the class as a function (e.g., `object_name = ClassName()`). |
    | **Purpose**             | The purpose of a class is to define properties (attributes) and behaviors (methods) that objects of that class will share. | The purpose of an object is to hold specific data and behaviors as defined by its class. |
    | **Example**             | `class Dog:` is a class definition. | `my_dog = Dog()` is an object created from the class `Dog`. |
    | **Memory**              | A class itself doesn‚Äôt hold any data but provides the structure for objects. | Each object holds its own data and uses the class‚Äôs methods. |
    | **Use**                 | A class is used to define and model entities and their behaviors in code. | An object represents a specific instance of the class in the program. |
    | **Attributes and Methods** | Defines the attributes and methods that objects of the class will have. | Objects have their own values for the attributes and can call the methods defined in the class. |


    **Example:**
    ```python
    # Class definition
    class Dog:
        # Class attributes (shared among all objects of this class)
        species = "Canine" 
        
        # Constructor method to initialize the object
        def __init__(self, name, age):
            self.name = name  # Instance variable
            self.age = age    # Instance variable

        # Method for the object
        def bark(self):
            print(f"{self.name} says woof!")

    # Creating objects (instances) of the Dog class
    dog1 = Dog("Buddy", 3)
    dog2 = Dog("Lucy", 5)

    # Accessing object attributes and methods
    print(dog1.name)  # Output: Buddy
    dog1.bark()       # Output: Buddy says woof!

    print(dog2.name)  # Output: Lucy
    dog2.bark()       # Output: Lucy says woof!


    ```
    **Explanation:**
    * `Dog` is a **class** that defines what attributes and behaviors (methods) a dog should have.

    * `dog1` and `dog2` are **objects** (instances of the class `Dog`). They hold their own data, like their names and ages, and can call the methods of the `Dog` class, like `bark()`.

    **Summary:**
    * **Class:** A blueprint that defines properties and behaviors.

    * **Object:** An instance created using the class, holding specific data.

6. ### What are the four pillars of OOP? Explain each
    The four pillars of **Object-Oriented Programming (OOP)** are **Encapsulation, Abstraction, Inheritance**, and **Polymorphism**. These concepts form the foundation of object-oriented programming and help in building modular, maintainable, and reusable software.

    **1. Encapsulation**
    Encapsulation is the bundling of data (attributes) and methods (functions) that operate on the data into a single unit, or class. It restricts direct access to some of an object's components, which helps to prevent accidental modification of data.

    * **Purpose:** To protect the internal state of an object and only allow it to be modified through controlled methods.

    * **How:** You can use access modifiers like private, protected, and public (though Python uses naming conventions like an underscore for "protected" and double underscores for "private").

    * **Benefits:** Ensures that the internal workings of an object are hidden and can only be accessed through specific methods, promoting safer and more predictable code.

    **Example of Encapsulation:**
    ```python
    class BankAccount:
        def __init__(self, balance):
            self.__balance = balance  # Private variable
        
        def deposit(self, amount):
            if amount > 0:
                self.__balance += amount
        
        def withdraw(self, amount):
            if 0 < amount <= self.__balance:
                self.__balance -= amount
        
        def get_balance(self):
            return self.__balance

    # Creating object
    account = BankAccount(1000)
    account.deposit(500)
    account.withdraw(200)
    print(account.get_balance())  # Output: 1300

    ```
    In this example, the `__balance` variable is private (encapsulated), and can only be modified via the `deposit` and `withdraw` methods, ensuring controlled access to the balance.

    **2. Abstraction**
    Abstraction is the concept of hiding the complex implementation details of a system and exposing only the necessary parts or functionalities to the user. It focuses on what an object does rather than how it does it.

    **Purpose:** To simplify the interface by exposing only relevant information and hiding the complexity.

    **How:** You can use abstract classes or interfaces (in some languages) to provide a blueprint for other classes, which only implement necessary details.

    **Benefits:** Helps to reduce complexity and makes the code easier to maintain and understand.

    **Example of Abstraction:**
    ```python
    from abc import ABC, abstractmethod

    class Animal(ABC):
        @abstractmethod
        def sound(self):
            pass

    class Dog(Animal):
        def sound(self):
            return "Bark"

    class Cat(Animal):
        def sound(self):
            return "Meow"

    # Creating objects
    dog = Dog()
    cat = Cat()
    print(dog.sound())  # Output: Bark
    print(cat.sound())  # Output: Meow

    ```
    In this example, `Animal` is an abstract class, and its method `sound `is abstract, meaning it must be implemented by any subclass. This allows us to abstract the concept of an "Animal" and hide the specific implementation details of `Dog` and `Cat`.

    **3. Inheritance**
    Inheritance allows one class (child class) to inherit the attributes and methods of another class (parent class). This promotes code reuse and the creation of a hierarchical class structure.

    * **Purpose:** To create a new class based on an existing class, inheriting its properties and methods while adding new functionality or modifying existing behavior.

    * **How:** The child class inherits from the parent class, and you can override or extend the functionality.

    * **Benefits:** Reduces redundancy and promotes reuse of code, making the software easier to maintain.

    **Example of Inheritance:**
    ```python
    class Animal:
        def __init__(self, name):
            self.name = name
        
        def speak(self):
            return "Animal sound"

    class Dog(Animal):
        def speak(self):
            return f"{self.name} says Woof!"

    # Creating objects
    dog = Dog("Buddy")
    print(dog.speak())  # Output: Buddy says Woof!


    ```
    In this example, Dog inherits from Animal. The Dog class has its own speak method that overrides the speak method of Animal.

    **4. Polymorphism**
    Polymorphism means "many forms". It allows objects of different classes to be treated as objects of a common superclass. It also allows methods to have the same name but behave differently depending on the object calling them.

    * **Purpose:** To enable a single interface to be used for different types of objects.

    * **How:** This is achieved by overriding methods in derived classes or using method overloading (same method name but different parameters).

    * **Benefits:** Makes the code more flexible and extensible, as it allows you to work with objects of different types in a uniform way.

    **Example of Polymorphism:**
    ```python

    class Bird:
        def sound(self):
            return "Tweet"

    class Dog:
        def sound(self):
            return "Woof"

    def make_sound(animal):
        print(animal.sound())

    # Creating objects
    bird = Bird()
    dog = Dog()

    make_sound(bird)  # Output: Tweet
    make_sound(dog)   # Output: Woof

    ```
    In this example, both Bird and Dog have a sound method, but each behaves differently. The make_sound function demonstrates polymorphism, as it can work with any object that has a sound method, regardless of the class type.

    #### **Summary of the Four Pillars of OOP:**
    **1. Encapsulation:** Hides internal object details and restricts direct access to attributes, ensuring controlled access.

    **2. Abstraction**: Hides complex implementation details and exposes only necessary parts of an object.

    **3. Inheritance:** Allows new classes to inherit attributes and methods from existing classes, promoting code reuse.

    **4. Polymorphism:** Allows objects of different classes to be treated as instances of a common superclass, enabling method overrides and providing flexibility.

    These principles work together to create modular, maintainable, and reusable code in object-oriented programming.

7. ### Real time example of each pillar
    ### **Real-Time Example of Each Pillar of OOP**

    ### **1. Encapsulation**
    **Definition:** Encapsulation is the concept of wrapping data and methods into a single unit, typically a class, and restricting direct access to some details.

    **Real-Time Example:**
    - A **bank account** class where account balance is a private attribute, and can only be accessed or modified through public methods like `deposit()` or `withdraw()`.

    ```python
    class BankAccount:
        def __init__(self, account_number, balance):
            self.account_number = account_number  # Public Attribute
            self.__balance = balance  # Private Attribute
        
        def deposit(self, amount):
            self.__balance += amount
        
        def withdraw(self, amount):
            if amount <= self.__balance:
                self.__balance -= amount
            else:
                print("Insufficient balance")
        
        def get_balance(self):
            return self.__balance

    # Usage
    account = BankAccount("123456", 1000)
    account.deposit(500)
    print(account.get_balance())  # Output: 1500
    ```

    ---

    ### **2. Inheritance**
    **Definition:** Inheritance allows a class (child) to acquire the properties and behaviors of another class (parent).

    **Real-Time Example:**
    - A **car** class inheriting properties from a **vehicle** class.

    ```python
    class Vehicle:
        def __init__(self, brand):
            self.brand = brand
        
        def start_engine(self):
            print("Engine started")

    class Car(Vehicle):
        def __init__(self, brand, model):
            super().__init__(brand)
            self.model = model

        def display_info(self):
            print(f"Car Brand: {self.brand}, Model: {self.model}")

    # Usage
    car = Car("Toyota", "Camry")
    car.start_engine()  # Inherited method
    car.display_info()  # Output: Car Brand: Toyota, Model: Camry
    ```

    ---

    ### **3. Polymorphism**
    **Definition:** Polymorphism allows different classes to be treated as the same type through a common interface.

    **Real-Time Example:**
    - A **shape** class where different shapes (circle, rectangle) implement their own version of the `area()` method.

    ```python
    class Shape:
        def area(self):
            pass

    class Circle(Shape):
        def __init__(self, radius):
            self.radius = radius
        
        def area(self):
            return 3.14 * self.radius * self.radius

    class Rectangle(Shape):
        def __init__(self, length, width):
            self.length = length
            self.width = width
        
        def area(self):
            return self.length * self.width

    # Usage
    shapes = [Circle(5), Rectangle(4, 6)]
    for shape in shapes:
        print(shape.area())  # Output: 78.5 for Circle, 24 for Rectangle
    ```

    ---

    ### **4. Abstraction**
    **Definition:** Abstraction hides implementation details and exposes only the necessary functionalities.

    **Real-Time Example:**
    - An **ATM machine** allows users to withdraw money without showing the internal banking process.

    ```python
    from abc import ABC, abstractmethod

    class ATM(ABC):
        @abstractmethod
        def withdraw(self, amount):
            pass

    class BankATM(ATM):
        def withdraw(self, amount):
            print(f"Withdrawing {amount} from ATM")

    # Usage
    atm = BankATM()
    atm.withdraw(500)  # Output: Withdrawing 500 from ATM
    ```

    ---

    ## **Conclusion**
    Each pillar of OOP plays a vital role in designing modular, scalable, and maintainable software. These real-world examples demonstrate how these concepts are applied in daily applications.



8. ### What is a Constructor
   

    ### **Definition:**
    A constructor is a special method in a class that gets called automatically when an object is instantiated. It is commonly used to initialize object attributes.

    ### **Example:**

    ```python
    class Person:
        def __init__(self, name, age):
            self.name = name  # Instance attribute
            self.age = age    # Instance attribute
        
        def display_info(self):
            print(f"Name: {self.name}, Age: {self.age}")

    # Creating an instance of the class
    person1 = Person("Alice", 25)
    person1.display_info()  # Output: Name: Alice, Age: 25
    ```

    ### **Key Points:**
    - The constructor method in Python is named `__init__`.
    - It is automatically invoked when an instance of the class is created.
    - It helps in initializing the attributes of the object.
    - Unlike regular methods, constructors do not need to be explicitly called.

    ### **Types of Constructors in Python:**
    1. **Default Constructor:** A constructor that does not take any parameters apart from `self`.
    ```python
    class Example:
        def __init__(self):
            print("Default Constructor Called")

    obj = Example()  # Output: Default Constructor Called
    ```

    2. **Parameterized Constructor:** A constructor that accepts parameters to initialize attributes.
    ```python
    class Example:
        def __init__(self, value):
            self.value = value
            print(f"Value: {self.value}")

    obj = Example(10)  # Output: Value: 10
    ```

    3. **Constructor with Default Arguments:** A constructor that provides default values for parameters.
    ```python
    class Example:
        def __init__(self, value=100):
            self.value = value
            print(f"Value: {self.value}")

    obj1 = Example()    # Output: Value: 100
    obj2 = Example(50)  # Output: Value: 50
    ```

    ### **Conclusion:**
    Constructors play a crucial role in object-oriented programming by ensuring that object attributes are properly initialized upon creation.


9. ### use of super and self keyword


    ### **`self` Keyword:**

    #### **Definition:**
    The `self` keyword in Python represents the instance of a class. It is used to access instance variables and methods within the class.

    #### **Example:**
    ```python
    class Person:
        def __init__(self, name, age):
            self.name = name  # Instance variable
            self.age = age    # Instance variable
        
        def display_info(self):
            print(f"Name: {self.name}, Age: {self.age}")

    # Creating an instance of the class
    person1 = Person("Alice", 25)
    person1.display_info()  # Output: Name: Alice, Age: 25
    ```

    #### **Key Points:**
    - `self` represents the current instance of the class.
    - It is required as the first parameter in instance methods.
    - It allows access to attributes and methods within the class.

    ---

    ### **`super` Keyword:**

    #### **Definition:**
    The `super` keyword is used to call a method from the parent class in a child class. It is commonly used in inheritance to invoke the constructor or other methods of the parent class.

    #### **Example:**
    ```python
    class Animal:
        def __init__(self, name):
            self.name = name
        
        def make_sound(self):
            print("Some generic animal sound")

    class Dog(Animal):
        def __init__(self, name, breed):
            super().__init__(name)  # Calling parent class constructor
            self.breed = breed
        
        def make_sound(self):
            super().make_sound()  # Calling parent class method
            print("Bark Bark!")

    # Creating an instance of Dog
    dog1 = Dog("Buddy", "Labrador")
    dog1.make_sound()
    ```

    #### **Key Points:**
    - `super()` allows access to parent class methods without explicitly naming the parent class.
    - It is commonly used in inheritance to reuse the functionality of the base class.
    - Helps in maintaining code reusability and avoids redundant code.

    ### **Conclusion:**
    Both `self` and `super` play a crucial role in object-oriented programming in Python. `self` allows an instance to refer to its own attributes and methods, whereas `super` provides access to methods from the parent class, promoting code reusability.



10. ### What are decorators and how to implement them


    ### **Definition:**
    Decorators in Python are functions that modify the behavior of other functions or methods without changing their code. They are often used to add functionality such as logging, authentication, or access control.

    ---

    ### **How Decorators Work:**
    A decorator is a function that takes another function as an argument and returns a new function with added functionality.

    #### **Example of a Simple Decorator:**
    ```python
    # Defining a decorator
    def my_decorator(func):
        def wrapper():
            print("Something is happening before the function is called.")
            func()
            print("Something is happening after the function is called.")
        return wrapper

    @my_decorator
    def say_hello():
        print("Hello!")

    say_hello()
    ```
    #### **Output:**
    ```
    Something is happening before the function is called.
    Hello!
    Something is happening after the function is called.
    ```

    ---

    ### **Using Decorators with Arguments:**
    Decorators can also accept arguments by using nested functions.

    #### **Example:**
    ```python
    # Decorator with arguments
    def repeat(n):
        def decorator(func):
            def wrapper(*args, **kwargs):
                for _ in range(n):
                    func(*args, **kwargs)
            return wrapper
        return decorator

    @repeat(3)
    def greet(name):
        print(f"Hello, {name}!")

    greet("Alice")
    ```

    #### **Output:**
    ```
    Hello, Alice!
    Hello, Alice!
    Hello, Alice!
    ```

    ---

    ### **Built-in Decorators in Python:**
    Python provides some built-in decorators, such as:
    - `@staticmethod` ‚Äì Defines a method that doesn‚Äôt depend on instance variables.
    - `@classmethod` ‚Äì Defines a method that operates on the class rather than an instance.
    - `@property` ‚Äì Used to create getter and setter methods.

    #### **Example:**
    ```python
    class MyClass:
        def __init__(self, value):
            self._value = value

        @property
        def value(self):
            return self._value

        @value.setter
        def value(self, new_value):
            self._value = new_value

    obj = MyClass(10)
    print(obj.value)  # Output: 10
    obj.value = 20
    print(obj.value)  # Output: 20
    ```

    ---

    ### **Conclusion:**
    Decorators are a powerful feature in Python that allow us to modify functions and methods in a clean and readable way. They are widely used in frameworks such as Flask and Django for authentication, logging, and performance monitoring.


11. ### What is `self` and `__init__`

    ### **Understanding `self` in Python**
    The `self` parameter in Python is a reference to the current instance of the class. It is used to access variables and methods within the class.

    #### **Example:**
    ```python
    class Person:
        def __init__(self, name, age):
            self.name = name  # Instance variable
            self.age = age
        
        def greet(self):
            print(f"Hello, my name is {self.name} and I am {self.age} years old.")

    person1 = Person("Alice", 25)
    person1.greet()
    ```
    #### **Output:**
    ```
    Hello, my name is Alice and I am 25 years old.
    ```

    ---

    ### **Understanding `__init__` Method**
    The `__init__` method is the constructor in Python classes. It is automatically called when an instance of the class is created. It is commonly used to initialize instance variables.

    #### **Example:**
    ```python
    class Car:
        def __init__(self, brand, model):
            self.brand = brand
            self.model = model
        
        def show_details(self):
            print(f"Car Brand: {self.brand}, Model: {self.model}")

    car1 = Car("Toyota", "Camry")
    car1.show_details()
    ```
    #### **Output:**
    ```
    Car Brand: Toyota, Model: Camry
    ```

    ---

    #### **Key Differences Between `self` and `__init__`**
    | Feature         | `self` | `__init__` |
    |---------------|-------|-----------|
    | Purpose | Refers to the instance of the class | Initializes instance variables |
    | Usage | Used inside class methods to access attributes and methods | Special method (constructor) automatically called when creating an object |
    | Explicit Call | Implicitly passed | Automatically invoked |

    ---

    ### **Conclusion**
    - `self` represents the instance of the class and allows access to attributes and methods.
    - `__init__` is a special method used to initialize object properties when an instance is created.
    - Together, they ensure proper object-oriented behavior in Python.

12. ### What is encapsulation? How is it implemented in Python

13. ### What is method overloading? Does Python support it
    ### **Method Overloading in Python:**
    **Method overloading** refers to the ability to define multiple methods with the same name in a class, but with different parameters (i.e., the method signature varies). This allows the method to behave differently based on the number or type of arguments passed to it.

    * In traditional object-oriented languages like Java or C++, method overloading is achieved by defining multiple methods with the same name but different parameter lists (number, type, or order of parameters).

    * **Python does not support method overloading** in the traditional sense. Python allows only one method with a given name in a class, and if you define multiple methods with the same name, the last one defined will overwrite the previous ones.

    However, Python provides alternatives to achieve **method overloading-like behavior**, typically using:

    1. Default arguments.

    2. Variable-length arguments (`*args`, `**kwargs`).

    ### **Traditional Method Overloading (In Other Languages):**
    In languages like Java, you could define multiple methods with the same name but different parameters, as shown below:
    ```python
    class Example {
        public void print(int num) {
            System.out.println(num);
        }
        
        public void print(String text) {
            System.out.println(text);
        }
    }

    ```
    In Python, if you try to define multiple methods with the same name, only the last definition will be used, like this:
    ```python
    class Example:
        def print(self, num):
            print(num)
        
        def print(self, text):
            print(text)

    # The second print method will override the first one.
    obj = Example()
    obj.print("Hello")  # Output: Hello

    ```
    ### How Python Simulates Method Overloading:
    Although Python does not support traditional method overloading, we can still achieve similar behavior using default parameters and variable-length argument lists.

    1. Using Default Arguments:
    You can provide default values for parameters, so the method can behave differently based on the provided arguments.

    ```python
    class Example:
        def print(self, value=None):
            if isinstance(value, int):
                print(f"Integer: {value}")
            elif isinstance(value, str):
                print(f"String: {value}")
            else:
                print("No argument provided")

    # Testing with different types of arguments
    obj = Example()
    obj.print(5)       # Output: Integer: 5
    obj.print("Hello")  # Output: String: Hello
    obj.print()         # Output: No argument provided

    ```
    In this example:

    * The method print uses a default argument None to handle different types of arguments and modify its behavior accordingly.

    2. **Using Variable-Length Arguments:**
    You can use `*args` and `**kwargs` to allow the method to accept any number of arguments
    ```python
    class Example:
        def print(self, *args):
            if len(args) == 1:
                print(f"Single argument: {args[0]}")
            elif len(args) > 1:
                print("Multiple arguments:", args)
            else:
                print("No argument provided")

    # Testing with variable arguments
    obj = Example()
    obj.print(5)                # Output: Single argument: 5
    obj.print("Hello", 10)      # Output: Multiple arguments: ('Hello', 10)
    obj.print()                 # Output: No argument provided

    ```
    In this example:

    The method print uses `*args` to accept a variable number of arguments and determine its behavior based on how many arguments are passed.

    **Conclusion:**
    * Python does **not** support traditional method overloading (having multiple methods with the same name but different signatures).

    * However, Python allows you to achieve similar behavior using **default arguments** and **variable-length arguments** (`*args, **kwargs`).

    * This gives flexibility in defining methods that can handle different numbers or types of arguments.

14. ### What is method overriding? Provide an example

    ### **Method Overriding in Python:**
    Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The method in the subclass has the same name, same parameters, and same return type as the method in the parent class, but with a new implementation.

    * **Purpose:** The main purpose of method overriding is to modify or extend the behavior of a method inherited from a superclass in the subclass.

    * **How:** The subclass defines a method with the same name as the one in the parent class, which overrides the parent class's method.

    * **Benefits:** Method overriding allows for customization of inherited methods without changing the original class.

    **Example of Method Overriding:**
    ```python
    # Parent class
    class Animal:
        def speak(self):
            print("The animal makes a sound")

    # Child class (overrides the speak method)
    class Dog(Animal):
        def speak(self):
            print("The dog barks")

    # Child class (overrides the speak method)
    class Cat(Animal):
        def speak(self):
            print("The cat meows")

    # Creating objects
    animal = Animal()
    dog = Dog()
    cat = Cat()

    # Calling the overridden method
    animal.speak()  # Output: The animal makes a sound
    dog.speak()     # Output: The dog barks
    cat.speak()     # Output: The cat meows

    ```
    **Explanation:**
    In this example, the **Animal** class has a **speak()** method that prints a generic message.

    Both Dog and Cat are subclasses of Animal, and each provides its own implementation of the speak() method. This is **method overriding.**

    When we call `speak()` on an object of `Dog` or `Cat`, the method of the respective subclass is executed, overriding the `speak()` method of the `Animal` class.

    ### **Key Points:**
    **1. Same Method Name:** The method in the subclass must have the same name as the one in the superclass.

    **2. Same Parameters:** The method in the subclass should have the same parameter list (although Python does allow flexible arguments).

    **3. Subtype Behavior:** Method overriding is typically used to implement subtype-specific behavior.

    ### **Use Case:**
    Method overriding is commonly used in situations where a base class defines a general behavior, and derived classes need to implement specific behaviors for their context (like the speak method in the Dog and Cat classes above).

15. ### What is the difference between public, private, and protected members in Python

    In Python, public, private, and protected are access modifiers that define the visibility and accessibility of attributes and methods in a class. Although Python does not strictly enforce access control as in some other languages (like C++ or Java), it follows a convention-based approach to indicate the intended accessibility of class members.

    ### 1. Public Members
    * **Definition:** Public members are the default members in Python. They can be accessed directly from outside the class, and there are no restrictions on accessing or modifying these members.

    * **Syntax:** No special prefix is needed for public members.

    **Example of Public Members:**
    ```python
    class Person:
        def __init__(self, name, age):
            self.name = name  # Public member
            self.age = age    # Public member

        def greet(self):
            print(f"Hello, my name is {self.name} and I am {self.age} years old.")

    # Creating an object
    person = Person("John", 25)

    # Accessing public members
    print(person.name)  # Output: John
    print(person.age)   # Output: 25
    person.greet()      # Output: Hello, my name is John and I am 25 years old.

    ```
    * **Access:** Public members (like name and age) can be accessed directly using person.name and person.age.

    ### 2. Protected Members
    * **Definition:** Protected members are intended to be accessible within the class and its subclasses (derived classes). They are not intended to be accessed directly outside the class or subclass, but Python allows it (this is just a convention).

    * **Syntax:** Protected members are indicated by a single underscore (_) before the member name.

    **Example of Protected Members:**

    ```python
    class Animal:
        def __init__(self, species, sound):
            self._species = species  # Protected member
            self._sound = sound      # Protected member

        def speak(self):
            print(f"The {self._species} says {self._sound}")

    # Subclass
    class Dog(Animal):
        def __init__(self, breed, sound):
            super().__init__("Dog", sound)
            self._breed = breed  # Protected member

        def speak(self):
            print(f"The {self._breed} barks!")

    # Creating an object
    dog = Dog("Bulldog", "Woof")
    dog.speak()  # Output: The Bulldog barks!

    # Accessing protected member (not recommended, but possible)
    print(dog._species)  # Output: Dog

    ```
    ### 3. Private Members
    **Definition:** Private members are meant to be restricted to the class in which they are defined. They cannot be accessed directly from outside the class or subclass. Private members are truly meant to be hidden.

    **Syntax:** Private members are indicated by a double underscore (__) before the member name. This triggers name mangling in Python, where the member's name is altered to make it harder (but not impossible) to access.

    **Example of Private Members:**
    ```python
    class BankAccount:
        def __init__(self, balance):
            self.__balance = balance  # Private member

        def deposit(self, amount):
            if amount > 0:
                self.__balance += amount

        def withdraw(self, amount):
            if amount <= self.__balance:
                self.__balance -= amount

        def get_balance(self):
            return self.__balance

    # Creating an object
    account = BankAccount(1000)

    # Accessing private member (will raise AttributeError)
    # print(account.__balance)  # This will raise an error!

    # Accessing private member using a mangled name (not recommended)
    print(account._BankAccount__balance)  # Output: 1000

    ```
    **Access:** Private members (e.g., __balance) cannot be accessed directly from outside the class. Python uses **name mangling** to make the attribute name unique, so it cannot be accessed using account.__balance. Instead, it can be accessed using account._BankAccount__balance, but this is not recommended.

    ### Summary of Access Levels:
    | Access Modifier | Description                                                       | Syntax     | Access From                    |
    |-----------------|-------------------------------------------------------------------|------------|--------------------------------|
    | **Public**      | Accessible from anywhere (inside and outside the class).         | No prefix  | Anywhere                       |
    | **Protected**   | Intended to be accessible only within the class and subclasses.   | `_` (single underscore) | Inside class and subclasses   |
    | **Private**     | Accessible only within the class; cannot be accessed outside.     | `__` (double underscore) | Inside the class only (name mangling applies) |


    **Key Points:**

    * **Public members** are meant to be accessed freely.

    * **Protected members** are meant to be accessed within the class and its subclasses, but accessing them directly from outside is discouraged.

    * **Private members** are intended to be hidden and are only accessible within the class. Python doesn't strictly enforce this, but it uses name mangling to discourage direct access from outside the class.

    Python's approach to access control is based on convention rather than enforcement. While you can access protected and private members, doing so goes against the intended design and may break the code's encapsulation.


16. ### How does Python method resolution order work in multiple inheritance


    ### **Understanding MRO in Python**
    Method Resolution Order (MRO) determines the sequence in which base classes are searched when calling a method in the presence of multiple inheritance. Python follows the **C3 Linearization (also known as the C3 superclass linearization algorithm)** to determine this order.

    ---

    ### **MRO in Single Inheritance**
    In single inheritance, the MRO is straightforward:
    - The method is first searched in the current class.
    - If not found, it moves to the parent class.
    - If still not found, it continues up the hierarchy until it reaches the `object` class.

    #### **Example: Single Inheritance MRO**
    ```python
    class A:
        def show(self):
            print("Method from A")

    class B(A):
        pass

    obj = B()
    obj.show()
    ```
    #### **Output:**
    ```
    Method from A
    ```

    Here, Python first checks `B` for `show()`, doesn't find it, and then looks in `A`.

    ---

    ### **MRO in Multiple Inheritance**
    In multiple inheritance, Python follows the **C3 Linearization** rule, which ensures a consistent, predictable order.
    - It starts with the child class.
    - Then checks parent classes in a depth-first, left-to-right manner.
    - Ensures that child classes are checked before their parents.
    - Prevents duplicate visits to the same class.

    #### **Example: Multiple Inheritance MRO**
    ```python
    class A:
        def show(self):
            print("Method from A")

    class B(A):
        def show(self):
            print("Method from B")

    class C(A):
        def show(self):
            print("Method from C")

    class D(B, C):
        pass

    obj = D()
    obj.show()
    ```
    #### **Output:**
    ```
    Method from B
    ```

    #### **MRO Order of Class D**
    To check the MRO of `D`, use:
    ```python
    print(D.mro())
    ```
    #### **Output:**
    ```
    [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
    ```
    Python follows **D ‚Üí B ‚Üí C ‚Üí A ‚Üí object**.

    ---

    ### **Diamond Problem & MRO Resolution**
    The **Diamond Problem** occurs when multiple inheritance leads to ambiguity.

    #### **Example: Diamond Problem**
    ```python
    class A:
        def show(self):
            print("Method from A")

    class B(A):
        def show(self):
            print("Method from B")

    class C(A):
        def show(self):
            print("Method from C")

    class D(B, C):
        pass

    obj = D()
    obj.show()
    ```
    #### **MRO Resolution:**
    Python resolves the ambiguity using **C3 Linearization**, ensuring `D ‚Üí B ‚Üí C ‚Üí A ‚Üí object` order.

    ---

    ### **Key Points About MRO in Python**
    1. Uses **C3 Linearization** to determine method lookup order.
    2. Follows a **depth-first, left-to-right** approach while ensuring consistency.
    3. Prevents redundant searches by visiting each class only once.
    4. The `mro()` method or `help(ClassName)` can be used to check MRO.

    ---

    ### **Conclusion**
    - MRO ensures predictable behavior in **multiple inheritance** scenarios.
    - Python resolves the **Diamond Problem** using the C3 linearization algorithm.
    - Understanding MRO is crucial for designing efficient class hierarchies in Python.

17. ### What is operator overloading?
# ‚öôÔ∏è What is Operator Overloading in Python?

## ‚úÖ Definition
**Operator Overloading** allows us to redefine the meaning of built-in operators (`+`, `-`, `*`, etc.) for user-defined objects (custom classes).

This means we can define how operators behave when used with objects of a class.

---

## üìò Why Use Operator Overloading?
- Makes code more intuitive and readable.
- Enables natural usage of operators with class instances.

---

## üîß How to Overload Operators?
Python provides **special methods** (also known as *magic methods* or *dunder methods*) for operator overloading:

| Operator | Method           |
|----------|------------------|
| `+`      | `__add__()`      |
| `-`      | `__sub__()`      |
| `*`      | `__mul__()`      |
| `/`      | `__truediv__()`  |
| `==`     | `__eq__()`       |
| `>`      | `__gt__()`       |
| `<`      | `__lt__()`       |

---

## üß± Example

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"

p1 = Point(2, 3)
p2 = Point(4, 5)
result = p1 + p2
print(result)  # Output: (6, 8)
```




1. ### Difference between tuple and dictionary.

| **Feature**         | **Tuple**                                      | **Dictionary**                              |
|---------------------|----------------------------------------------|-------------------------------------------|
| **Definition**      | An **ordered** collection of elements        | A collection of **key-value** pairs      |
| **Mutable?**       | **Immutable** (cannot be modified)           | **Mutable** (can add, update, and delete items) |
| **Syntax**         | `()` (parentheses)                           | `{}` (curly braces)                      |
| **Accessing Elements** | Accessed using **indexing** (e.g., `t[0]`) | Accessed using **keys** (e.g., `d['key']`) |
| **Duplicates Allowed?** | Yes (can contain duplicate values)        | No (keys must be unique)                 |
| **Performance**     | Faster due to immutability                  | Slightly slower due to key hashing       |
| **Use Case**       | Storing **fixed** collections of values      | Storing **mapped relationships**         |

2. ### Difference between tuple and set.
| **Feature**         | **Tuple**                                  | **Set**                                 |
|---------------------|------------------------------------------|----------------------------------------|
| **Definition**      | An **ordered** collection of elements   | An **unordered** collection of unique elements |
| **Mutable?**       | **Immutable** (cannot be modified)      | **Mutable** (can add/remove elements) |
| **Syntax**         | `()` (parentheses)                      | `{}` (curly braces)                   |
| **Duplicates Allowed?** | Yes (can contain duplicate values) | No (duplicates are automatically removed) |
| **Accessing Elements** | Accessed using **indexing** (e.g., `t[0]`) | No indexing (unordered structure) |
| **Ordering**       | Maintains insertion order              | Does not maintain order (unordered) |
| **Performance**    | Faster for **fixed** data retrieval    | Faster for **membership testing** (`O(1)`) |
| **Use Case**       | Storing **fixed sequences** of values  | Storing **unique elements** for fast lookup |

3. ###  Difference between map() and filter().
## Difference Between `map()` and `filter()` in Python

| Feature                    | `map()`                                                                 | `filter()`                                                                 |
|---------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------|
| **Purpose**               | Applies a function to each element of an iterable and returns a new iterable with transformed values. | Applies a function to each element of an iterable and returns only the elements that satisfy the condition (i.e., for which the function returns `True`). |
| **Output**                | Returns an iterable (`map` object) with the transformed values.          | Returns an iterable (`filter` object) containing only the elements that satisfy the condition. |
| **Function Type**         | Used for **modification** or **transformation** of data.                 | Used for **filtering out** elements based on a condition.                 |
| **Return Type**           | `map` object (can be converted to `list`, `tuple`, etc.)                 | `filter` object (can be converted to `list`, `tuple`, etc.)              |
| **Number of Elements in Output** | Same as the input iterable (each element is transformed).                | Can be **less than or equal to** the input iterable (only matching elements are returned). |
| **Syntax**        | `map(function, iterable)` | `filter(function, iterable)` |
| **Use Case**      | When you need to **modify** all elements | When you need to **filter out** elements based on a condition |
| **Example Usage** | `map(lambda x: x * 2, [1, 2, 3])  ‚Üí [2, 4, 6]` | `filter(lambda x: x % 2 == 0, [1, 2, 3, 4])  ‚Üí [2, 4]` |




6. ### Difference between append() and extend().
| **Feature**       | **`append()`**                                  | **`extend()`**                                |
|-------------------|-----------------------------------------------|---------------------------------------------|
| **Purpose**       | Adds a **single element** to the list         | Adds **multiple elements** (iterable) to the list |
| **Modification**  | Adds the element as **a single item**         | Iterates through the iterable and **adds elements individually** |
| **Return Type**   | **Modifies the list in place**, returns `None` | **Modifies the list in place**, returns `None` |
| **Effect on List Length** | Increases by **1** regardless of element type | Increases by the **number of elements in the iterable** |
| **Usage**         | `list.append([1, 2]) ‚Üí [[1, 2]]` (Nested list) | `list.extend([1, 2]) ‚Üí [1, 2]` (Flattened) |
| **Use Case**      | When you want to add **one item** (including another list as a single element) | When you want to **merge another list or iterable** into the existing list |

Example
```python
# Using append()
my_list = [1, 2, 3]
my_list.append([4, 5])
print(my_list)  # Output: [1, 2, 3, [4, 5]]  (Nested list)

# Using extend()
my_list = [1, 2, 3]
my_list.extend([4, 5])
print(my_list)  # Output: [1, 2, 3, 4, 5]  (Flattened list)
```



9. ###  Difference between remove() and pop().
| **Feature**       | **`remove()`**                              | **`pop()`**                               |
|-------------------|-------------------------------------------|-----------------------------------------|
| **Purpose**       | Removes a **specific value** from the list | Removes an **element by index** and returns it |
| **Arguments**     | Takes **a value** as an argument           | Takes an **index** as an argument (default: last element) |
| **Return Value**  | Returns `None` (modifies the list in place) | Returns the removed element |
| **Error Handling** | Raises `ValueError` if the value is not found | Raises `IndexError` if the index is out of range |
| **Usage**         | `list.remove(3)` (removes first occurrence of `3`) | `list.pop(2)` (removes and returns element at index `2`) |
| **Effect on List** | Shrinks list by **removing the first occurrence** of the value | Shrinks list by **removing an element at a specific position** |


#### Example Usage:
```python
# Using remove()
my_list = [1, 2, 3, 4, 3]
my_list.remove(3)  # Removes the first occurrence of 3
print(my_list)  # Output: [1, 2, 4, 3]

# Using pop()
my_list = [1, 2, 3, 4]
removed_item = my_list.pop(2)  # Removes and returns element at index 2
print(my_list)  # Output: [1, 2, 4]
print(removed_item)  # Output: 3

```
#### Key Takeaways:
* remove() removes a value (first occurrence).

* pop() removes an element at a specific index and returns it.

* remove() raises an error if the value is not found.

* pop() raises an error if the index is out of range






11. ### Difference between split() and partition().

| **Feature**       | **`split()`**                              | **`partition()`**                        |
|-------------------|------------------------------------------|-----------------------------------------|
| **Purpose**       | Splits a string into a **list of substrings** | Splits a string into **three parts**: before, separator, and after |
| **Return Type**   | Returns a **list** of substrings         | Returns a **tuple** (`before, separator, after`) |
| **Arguments**     | `split(separator, maxsplit)` (default separator: whitespace) | `partition(separator)` (only one split at first occurrence) |
| **Max Splits?**   | Yes, you can limit splits using `maxsplit` | No, always splits at **first occurrence** of separator |
| **If Separator Not Found?** | Returns **entire string as a list** | Returns `('original_string', '', '')` |
| **Example Usage** | `"a,b,c".split(',') ‚Üí ['a', 'b', 'c']`  | `"a,b,c".partition(',') ‚Üí ('a', ',', 'b,c')` |
| **Use Case**      | When you need to **break a string into multiple parts** | When you need to **extract text around the first occurrence** of a separator |


Example Usage:
```python
# Using split()
text = "apple,banana,cherry"
result = text.split(",")
print(result)  # Output: ['apple', 'banana', 'cherry']

# Using partition()
text = "apple,banana,cherry"
result = text.partition(",")
print(result)  # Output: ('apple', ',', 'banana,cherry')

```
**Key Takeaways:**
* split() breaks a string into multiple parts and returns a list.

* partition() splits only at the first occurrence and returns a tuple.

* If the separator is not found, split() returns the whole string as a list, while partition() returns the whole string as the first tuple element, followed by two empty strings.

12. ### Difference between find() and index().
| **Feature**       | **`find()`**                              | **`index()`**                             |
|-------------------|-----------------------------------------|-----------------------------------------|
| **Purpose**       | Returns the **index of the first occurrence** of a substring | Returns the **index of the first occurrence** of a substring |
| **Return Type**   | Returns **index** if found, otherwise `-1` | Returns **index** if found, otherwise raises `ValueError` |
| **Error Handling** | Does **not raise an error** if substring is not found | **Raises an error** if substring is not found |
| **Usage**         | `string.find("sub")` | `string.index("sub")` |
| **Performance**   | Both have **similar performance** | Both have **similar performance** |
| **Use Case**      | When you **don't want errors** and just need the index or `-1` | When the substring **must exist**, otherwise an error should occur |

#### Example Usage
```python
# Using find()
text = "hello world"
print(text.find("world"))  # Output: 6
print(text.find("Python"))  # Output: -1 (No error)

# Using index()
print(text.index("world"))  # Output: 6
print(text.index("Python"))  # Raises ValueError: substring not found
```
**Key Takeaways:**
* find() returns -1 if the substring is not found, making it safer.

* index() raises an error (ValueError) if the substring is not found.

* Use find() when checking if a substring exists without errors.

* Use index() when you are sure the substring exists and want an error if it doesn‚Äôt.



13. ### Difference between upper() and capitalize().
| **Feature**       | **`upper()`**                              | **`capitalize()`**                        |
|-------------------|------------------------------------------|-----------------------------------------|
| **Purpose**       | Converts **all characters** to uppercase | Converts **only the first character** to uppercase and the rest to lowercase |
| **Return Type**   | Returns a **new string** with all uppercase characters | Returns a **new string** with only the first letter capitalized |
| **Modification**  | Affects **entire string**                | Affects **only the first letter** of the string |
| **Example Usage** | `"hello world".upper() ‚Üí "HELLO WORLD"`  | `"hello world".capitalize() ‚Üí "Hello world"` |
| **Use Case**      | When you need a string in **all uppercase** | When you need to **capitalize only the first letter** of a sentence |


#### Example usage:
```python
# Using upper()
text = "hello world"
print(text.upper())  # Output: "HELLO WORLD"

# Using capitalize()
text = "hello world"
print(text.capitalize())  # Output: "Hello world"
```
**Key Takeaways:**
* upper() converts all characters to uppercase.

* capitalize() converts only the first character to uppercase and makes the rest lowercase.

* Use upper() when you need all uppercase text.

* Use capitalize() when you need only the first letter capitalized (like in a sentence).

---

## Intermediate level
| **Feature**       | **`global`**                            | **`nonlocal`**                          |
|-------------------|--------------------------------------|--------------------------------------|
| **Purpose**       | Declares a variable as **global**, meaning it belongs to the global scope | Declares a variable as **nonlocal**, meaning it belongs to an enclosing (but not global) scope |
| **Scope**         | Affects **global variables** across the entire script | Affects **variables in an enclosing function (not global scope)** |
| **Where to Use?** | Inside functions to modify a global variable | Inside nested functions to modify a variable from the outer (non-global) function |
| **Example Usage** | `global x` (Modifies `x` from global scope inside a function) | `nonlocal x` (Modifies `x` from an outer but non-global function) |
| **Works In?**     | **Any function** modifying a global variable | **Nested functions** modifying a variable from the enclosing function |
| **Error Handling** | Raises `UnboundLocalError` if a global variable is accessed before assignment | Raises `SyntaxError` if used outside a nested function |

## Example Usage:
```python
# Using global
x = 10  # Global variable

def modify_global():
    global x  # Declaring x as global
    x = 20  # Modifies the global variable

modify_global()
print(x)  # Output: 20

# Using nonlocal
def outer_function():
    y = 5  # Local variable in outer function

    def inner_function():
        nonlocal y  # Declaring y as nonlocal
        y = 15  # Modifies y from the outer function

    inner_function()
    print(y)  # Output: 15

outer_function()

```

**Key Takeaways:**
* global is used to modify global variables inside a function.

* nonlocal is used to modify variables from an enclosing function (but not global variables).

* global works anywhere inside a function, while nonlocal works only in nested functions.

* global affects global scope, while nonlocal affects enclosing function scope.




31. ### Difference between global scope and local scope.



| **Feature**      | **Global Scope**                                | **Local Scope**                               |
|-----------------|----------------------------------------------|----------------------------------------------|
| **Definition**  | The region of a program where global variables are accessible, typically the entire script. | The region of a program where local variables are accessible, usually within a function. |
| **Scope**      | Available throughout the program, including inside functions (unless shadowed). | Available only within the function where it is declared. |
| **Persistence** | Exists throughout the execution of the program. | Created when the function is called and destroyed when the function exits. |
| **Modification** | Can be modified inside a function using the `global` keyword. | Cannot be directly modified outside its function. |
| **Use Case**    | Useful for constants or variables that need to be accessed globally. | Useful for temporary data specific to a function. |
| **Example**     | `x = 10` (Declared outside function, accessible inside functions) | `def func(): x = 5` (Only accessible within `func()`) |


### **Example Usage**

#### **Global Scope Example**
```python
x = 10  # Global variable

def show():
    print(x)  # Accessible inside the function

show()  # Output: 10
```

#### **Local Scope Example**
```python
def show():
    x = 5  # Local variable
    print(x)

show()  # Output: 5
print(x)  # Raises NameError: name 'x' is not defined
```

### **Using `global` Keyword**
```python
x = 10  # Global variable

def modify():
    global x  # Access and modify global variable
    x = 20

modify()
print(x)  # Output: 20
```

### **Key Takeaways:**
- **Global scope** means a variable is accessible anywhere in the program unless shadowed by a local variable.
- **Local scope** means a variable is only accessible within the function where it is declared.
- Use the `global` keyword to modify a global variable inside a function.





27. ### Difference between `remove()` and `discard()` in Sets


| **Feature**      | **remove()**                                    | **discard()**                                   |
|-----------------|----------------------------------------------|----------------------------------------------|
| **Definition**  | Removes a specified element from the set. If the element is not found, it raises a `KeyError`. | Removes a specified element from the set. If the element is not found, it **does not** raise an error. |
| **Error Handling** | Raises `KeyError` if the element is missing. | Does **not** raise an error if the element is missing. |
| **Mutability**  | Modifies the original set.                    | Modifies the original set. |
| **Return Type** | Returns `None` (modifies in place).           | Returns `None` (modifies in place). |
| **Usage**       | Use when you **know** the element exists in the set. | Use when you're **not sure** if the element exists. |
| **Example**     | `A.remove(3)` ‚Üí If `3` is not present, raises an error. | `A.discard(3)` ‚Üí If `3` is not present, no error is raised. |


### **Example Usage**

#### **Using `remove()`** (Raises an error if element is missing)
```python
A = {1, 2, 3}
A.remove(2)
print(A)  # Output: {1, 3}
A.remove(5)  # Raises KeyError since 5 is not in the set.
```

#### **Using `discard()`** (No error if element is missing)
```python
A = {1, 2, 3}
A.discard(2)
print(A)  # Output: {1, 3}
A.discard(5)  # No error, even though 5 is not in the set.
```

### **Key Takeaways:**
- **Use `remove()`** when you **know** the element exists and want an error if it doesn‚Äôt.
- **Use `discard()`** when you **don‚Äôt want an error** if the element is missing.


36. ### Difference between encapsulation and abstraction

### üîê Difference Between Encapsulation and Abstraction in Python

| Feature           | Encapsulation                                           | Abstraction                                              |
|-------------------|---------------------------------------------------------|-----------------------------------------------------------|
| **Definition**     | Wrapping data and methods into a single unit (class).  | Hiding internal details and showing only essential info.  |
| **Focus**          | Protects data from outside interference.               | Hides complexity and provides a simplified interface.     |
| **Access**         | Uses access modifiers (public, protected, private).    | Uses abstract classes and methods (via `abc` module).     |
| **Goal**           | Data security and control.                             | Simplify the usage and implementation of complex systems. |
| **Implementation** | Achieved using classes and private/protected members.  | Achieved using abstract classes and interfaces.           |
| **Example**        | Making variables private using `__var`.                | Hiding method logic using `@abstractmethod`.              |

---

### ‚úÖ Example of Encapsulation

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # private variable

    def get_balance(self):
        return self.__balance

    def deposit(self, amount):
        self.__balance += amount
```

### ‚úÖ Example of Abstraction
```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        print("Bark")

```
* **Encapsulation**=Data hiding
* **Abstraction**=Complexity hiding
