
### Table of content
<!-- TOC_START -->
| No. | Questions |
| --- | --------- |
| 1 | [What is Python?](#what-is-python) |
| 2 | [Why is Python so popular?](#why-is-python-so-popular) |
| 3 | [How to install Python?](#how-to-install-python) |
| 4 | [What are the applications of Python?](#what-are-the-applications-of-python) |
| 5 | [What are the advantages of Python?](#what-are-the-advantages-of-python) |
| 6 | [What are the limitations of Python?](#what-are-the-limitations-of-python) |
| 7 | [What are literals in Python?](#what-are-literals-in-python) |
| 8 | [What is PEP 8, and why is it important?](#what-is-pep-8-and-why-is-it-important) |
| 9 | [What is an interpreted language?](#what-is-an-interpreted-language) |
| 10 | [What is the difference between a compiled and an interpreted language?](#what-is-the-difference-between-a-compiled-and-an-interpreted-language) |
| 11 | [How to check the Python version on your system?](#how-to-check-the-python-version-on-your-system) |
| 12 | [What are keywords in Python?](#what-are-keywords-in-python) |
| 13 | [What is indentation, and why is it important in Python?](#what-is-indentation-and-why-is-it-important-in-python) |
| 14 | [What is the difference between == and = in Python?](#what-is-the-difference-between-==-and-=-in-python) |
| 15 | [How can you print without a newline in Python?](#how-can-you-print-without-a-newline-in-python) |
| 16 | [What are variables in Python?](#what-are-variables-in-python) |
| 17 | [What is dynamic typing in Python?](#what-is-dynamic-typing-in-python) |
| 18 | [What are built-in data types in Python?](#what-are-built-in-data-types-in-python) |
| 19 | [What is type casting in Python?](#what-is-type-casting-in-python) |
| 20 | [What are global and local variables?](#what-are-global-and-local-variables) |
| 21 | [What is the difference between a list and a tuple?](#what-is-the-difference-between-a-list-and-a-tuple) |
| 22 | [How do you create a tuple with one element?](#how-do-you-create-a-tuple-with-one-element) |
| 23 | [What is tuple unpacking?](#what-is-tuple-unpacking) |
| 24 | [How do you concatenate two lists in Python?](#how-do-you-concatenate-two-lists-in-python) |
| 25 | [What is a dictionary in Python?](#what-is-a-dictionary-in-python) |
| 26 | [How do you access elements in a dictionary?](#how-do-you-access-elements-in-a-dictionary) |
| 27 | [What is the difference between pop() and remove() in lists?](#what-is-the-difference-between-pop-and-remove-in-lists) |
| 28 | [What is the difference between append() and extend() in lists?](#what-is-the-difference-between-append-and-extend-in-lists) |
| 29 | [What is a set in Python?](#what-is-a-set-in-python) |
| 30 | [What is the difference between a set and a frozenset?](#what-is-the-difference-between-a-set-and-a-frozenset) |
| 31 | [What is a string in Python?](#what-is-a-string-in-python) |
| 32 | [How do you reverse a string in Python?](#how-do-you-reverse-a-string-in-python) |
| 33 | [What is string interpolation?](#what-is-string-interpolation) |
| 34 | [What is an f-string?](#what-is-an-f-string) |
| 35 | [How can you split a string into a list?](#how-can-you-split-a-string-into-a-list) |
| 36 | [How do you check if a string contains a substring?](#how-do-you-check-if-a-string-contains-a-substring) |
| 37 | [How do you replace a substring in a string?](#how-do-you-replace-a-substring-in-a-string) |
| 38 | [What is string slicing?](#what-is-string-slicing) |
| 39 | [What are negative indices in Python?](#what-are-negative-indices-in-python) |
| 40 | [What is the difference between str() and repr()?](#what-is-the-difference-between-str-and-repr) |
| 41 | [What are list comprehensions?](#what-are-list-comprehensions) |
| 42 | [What is the difference between list comprehension and a loop?](#what-is-the-difference-between-list-comprehension-and-a-loop) |
| 43 | [What are generators in Python?](#what-are-generators-in-python) |
| 44 | [What is the yield keyword?](#what-is-the-yield-keyword) |
| 45 | [What is a lambda function?](#what-is-a-lambda-function) |
| 46 | [What is the difference between map() and filter()?](#what-is-the-difference-between-map-and-filter) |
| 47 | [What is the difference between map() and list comprehension?](#what-is-the-difference-between-map-and-list-comprehension) |
| 48 | [What is the use of the zip() function?](#what-is-the-use-of-the-zip-function) |
| 49 | [What is a function in Python?](#what-is-a-function-in-python) |
| 50 | [How do you define a function in Python?](#how-do-you-define-a-function-in-python) |
| 51 | [What is a docstring?](#what-is-a-docstring) |
| 52 | [What is the difference between a function and a method?](#what-is-the-difference-between-a-function-and-a-method) |
| 53 | [What are default arguments?](#what-are-default-arguments) |
| 54 | [What are positional arguments?](#what-are-positional-arguments) |
| 55 | [What are keyword arguments?](#what-are-keyword-arguments) |
| 56 | [What are *args and **kwargs?](#what-are-args-and-kwargs) |
| 57 | [What is recursion in Python?](#what-is-recursion-in-python) |
| 58 | [What is the base case in recursion?](#what-is-the-base-case-in-recursion) |
| 59 | [How to avoid infinite recursion?](#how-to-avoid-infinite-recursion) |
| 60 | [What is a module in Python?](#what-is-a-module-in-python) |
| 61 | [How do you import a module?](#how-do-you-import-a-module) |
| 62 | [What is the difference between import and from import?](#what-is-the-difference-between-import-and-from-import) |
| 63 | [What is the __name__ variable?](#what-is-the-__name__-variable) |
| 64 | [What is the purpose of if __name__ == '__main__':?](#what-is-the-purpose-of-if-__name__--main) |
| 65 | [What are packages in Python?](#what-are-packages-in-python) |
| 66 | [What is the purpose of the __init__.py file?](#what-is-the-purpose-of-the-__init__.py-file) |
| 67 | [How do you install external packages using pip?](#how-do-you-install-external-packages-using-pip) |
| 68 | [What is file handling in Python?](#what-is-file-handling-in-python) |
| 69 | [How do you open a file in Python?](#how-do-you-open-a-file-in-python) |
| 70 | [What are the different file modes in Python?](#what-are-the-different-file-modes-in-python) |
| 71 | [How do you read from a file?](#how-do-you-read-from-a-file) |
| 72 | [How do you write to a file?](#how-do-you-write-to-a-file) |
| 73 | [How do you close a file?](#how-do-you-close-a-file) |
| 74 | [What is the with statement in file handling?](#what-is-the-with-statement-in-file-handling) |
| 75 | [What is exception handling?](#what-is-exception-handling) |
| 76 | [What are try, except, else, and finally blocks?](#what-are-try-except-else-and-finally-blocks) |
| 77 | [What is the difference between syntax errors and exceptions?](#what-is-the-difference-between-syntax-errors-and-exceptions) |
| 78 | [How do you raise an exception?](#how-do-you-raise-an-exception) |
| 79 | [What is the assert statement in Python?](#what-is-the-assert-statement-in-python) |
| 80 | [What is the purpose of the raise keyword?](#what-is-the-purpose-of-the-raise-keyword) |
| 81 | [What are built-in exceptions in Python?](#what-are-built-in-exceptions-in-python) |
| 82 | [How can you create a custom exception?](#how-can-you-create-a-custom-exception) |
| 83 | [What is a class in Python?](#what-is-a-class-in-python) |
| 84 | [What is an object in Python?](#what-is-an-object-in-python) |
| 85 | [How do you create a class?](#how-do-you-create-a-class) |
| 86 | [What is the __init__ method?](#what-is-the-__init__-method) |
| 87 | [What is self in Python?](#what-is-self-in-python) |
| 88 | [What are class variables and instance variables?](#what-are-class-variables-and-instance-variables) |
| 89 | [What is inheritance in Python?](#what-is-inheritance-in-python) |
| 90 | [What is single inheritance?](#what-is-single-inheritance) |
| 91 | [What is multiple inheritance?](#what-is-multiple-inheritance) |
| 92 | [What is multi-level inheritance?](#what-is-multi-level-inheritance) |
| 93 | [What is hybrid inheritance?](#what-is-hybrid-inheritance) |
| 94 | [What is polymorphism?](#what-is-polymorphism) |
| 95 | [What is method overloading?](#what-is-method-overloading) |
| 96 | [What is method overriding?](#what-is-method-overriding) |
| 97 | [What is encapsulation?](#what-is-encapsulation) |
| 98 | [What is abstraction?](#what-is-abstraction) |
| 99 | [What are access modifiers in Python?](#what-are-access-modifiers-in-python) |
| 100 | [What is the difference between public, protected, and private members?](#what-is-the-difference-between-public-protected-and-private-members) |



1. ### What is Python

Python is a **high-level, interpreted, and dynamically typed** programming language. It is known for its **simplicity, readability, and ease of use**. Python supports multiple programming paradigms, including **procedural, object-oriented, and functional programming**.  

It is widely used in various fields, such as:  
- **Web Development** (Django, Flask)  
- **Data Science & Machine Learning** (Pandas, NumPy, Scikit-learn)  
- **Automation & Scripting**  
- **Cybersecurity & Ethical Hacking**  
- **Embedded Systems & IoT**  

Python is also **cross-platform** and has a **large standard library**, making it one of the most popular programming languages today. üöÄ  

---

2. ### Why is Python so popular 

Python is popular due to its **simplicity, versatility, and strong community support**. Some key reasons for its popularity include:  

- **Easy-to-read syntax** ‚Äì Python code is simple and resembles natural language, making it beginner-friendly.  
- **Large standard library** ‚Äì Comes with built-in modules for various tasks like file handling, networking, and databases.  
- **Cross-platform compatibility** ‚Äì Runs on Windows, macOS, and Linux without modification.  
- **Wide range of applications** ‚Äì Used in web development, data science, AI, automation, and more.  
- **Strong community support** ‚Äì A vast number of tutorials, forums, and third-party libraries make development easier.  
- **Extensive third-party packages** ‚Äì Tools like NumPy, Pandas, and TensorFlow extend Python‚Äôs functionality.  

Due to these features, Python is widely used in **software development, data analysis, artificial intelligence, and automation**. üöÄ  

---
3. ### How to install Python
---
4. ### What are the applications of Python 

Python is a **versatile** programming language used in various fields due to its **simplicity, flexibility, and extensive libraries**. Some of the major applications of Python include:  

- **Web Development** ‚Äì Frameworks like Django and Flask are used to build dynamic and scalable web applications.  
- **Data Science & Analytics** ‚Äì Libraries such as Pandas, NumPy, and Matplotlib help in data processing and visualization.  
- **Machine Learning & AI** ‚Äì TensorFlow, Scikit-learn, and PyTorch enable the development of intelligent applications.  
- **Automation & Scripting** ‚Äì Python automates repetitive tasks, such as file handling, data entry, and web scraping.  
- **Cybersecurity & Ethical Hacking** ‚Äì Security experts use Python for penetration testing and malware analysis.  
- **Game Development** ‚Äì Pygame and Panda3D are used to develop 2D and 3D games.  
- **Embedded Systems & IoT** ‚Äì Python is used in Raspberry Pi and Arduino-based IoT applications.  
- **Software Testing & Automation** ‚Äì Selenium and PyTest help in automating software testing.  
- **Blockchain & Cryptocurrency** ‚Äì Developers use Python to build blockchain-based applications.  
- **Networking** ‚Äì Python is used for network programming, socket programming, and server automation.  

Python's **cross-platform compatibility** and **extensive support for third-party libraries** make it a preferred choice for various domains. üöÄ  

---

5. ### What are the advantages of Python 

Python offers several advantages, making it one of the most popular programming languages today:  

- **Easy to Learn & Use** ‚Äì Python has a simple syntax similar to English, making it beginner-friendly.  
- **High-Level Language** ‚Äì Developers don‚Äôt need to manage memory manually.  
- **Interpreted Language** ‚Äì Python executes code line by line, making debugging easier.  
- **Cross-Platform** ‚Äì Python runs on multiple operating systems (Windows, macOS, Linux).  
- **Extensive Libraries & Frameworks** ‚Äì Libraries like NumPy, Pandas, TensorFlow, and Django support various applications.  
- **Community Support** ‚Äì A vast global community provides documentation, tutorials, and troubleshooting support.  
- **Versatile** ‚Äì Python is used in web development, data science, AI, automation, cybersecurity, and more.  
- **Dynamically Typed** ‚Äì No need to declare variable types explicitly.  
- **Integration & Extensibility** ‚Äì Python can integrate with C, C++, Java, and other languages.  

Python‚Äôs simplicity and power make it an excellent choice for developers of all levels. üöÄ

---

6. ### What are the limitations of Python  

Despite its advantages, Python has some limitations:  

- **Slower Execution Speed** ‚Äì Since Python is an interpreted language, it runs slower than compiled languages like C or Java.  
- **High Memory Consumption** ‚Äì Python uses more memory due to its flexible data types and dynamic typing.  
- **Global Interpreter Lock (GIL)** ‚Äì Python‚Äôs GIL restricts multi-threaded execution, making it less efficient for CPU-bound tasks.  
- **Not Ideal for Mobile Development** ‚Äì Python is not commonly used for mobile applications due to performance concerns.  
- **Limited Database Access** ‚Äì Python‚Äôs database access layers are not as robust as those in Java or C++.  
- **Weak in Multi-Core Processing** ‚Äì Due to GIL, Python struggles with parallel processing in multi-core CPUs.  
- **Dependency Management** ‚Äì Managing dependencies in larger projects can be complex compared to languages like JavaScript with Node.js.  

While Python is powerful, these limitations should be considered when selecting it for a project. üîç

[Back to Top](#table-of-content) 
---
7. ### What are literals in Python  

Literals in Python are fixed values assigned directly to variables or constants. They represent data without requiring computation. Python has different types of literals:  

#### 1. **String Literals**  
Represent text enclosed in single, double, or triple quotes.  

```python
single_quote = 'Hello'
double_quote = "Hello"
triple_quote = '''Hello, this is a multi-line string'''
```

### 2. Numeric Literals
Include integers, floating-point numbers, and complex numbers.

```python
integer_num = 10         # Integer literal
float_num = 3.14         # Float literal
complex_num = 3 + 4j     # Complex literal

```
### 3. Boolean Literals
Represent truth values: True or False.

```python
is_python_easy = True
is_java_better = False
```
### 4. Special Literal
Python provides a special literal None to indicate the absence of a value.

```python
no_value = None
```
### 5. List, Tuple, Dictionary, and Set Literals
Collections of data in different formats.

```python
list_literal = [1, 2, 3, "Python"]     # List literal
tuple_literal = (10, 20, 30)           # Tuple literal
dict_literal = {'name': 'Alice', 'age': 25}  # Dictionary literal
set_literal = {1, 2, 3, 4}             # Set literal
```
Literals make code more readable and easy to understand. üöÄ


---

8. ### What is PEP 8, and why is it important

**PEP 8 (Python Enhancement Proposal 8)** is the official style guide for writing Python code. It provides guidelines to improve the readability, consistency, and maintainability of Python programs.

#### üîπ **Why is PEP 8 important?**
- ‚úÖ **Improves Readability** ‚Äì Ensures code is easy to read and understand.
- ‚úÖ **Encourages Consistency** ‚Äì Helps developers follow the same coding conventions.
- ‚úÖ **Enhances Collaboration** ‚Äì Makes it easier for teams to work on the same codebase.
- ‚úÖ **Industry Standard** ‚Äì Many companies and open-source projects follow PEP 8.

#### üîπ **Key PEP 8 Guidelines**
1. **Indentation** ‚Äì Use **4 spaces per indentation level**.
   ```python
   def greet():
       print("Hello, World!")  # 4-space indentation
   ```
Maximum Line Length ‚Äì Keep lines ‚â§ 79 characters for better readability.

```python
message = "This is a long line, but it should ideally be within 79 characters."
```
Blank Lines ‚Äì Use 2 blank lines between top-level functions and classes.

```python
class MyClass:
    pass

def my_function():
    pass
```
Naming Conventions:

Use snake_case for variables and functions.

Use CamelCase for class names.

Use ALL_CAPS for constants.

```python
class MyClass:
    MY_CONSTANT = 100  # Constant
    
    def my_function(self):  # Function name
        my_variable = "Hello"  # Variable name
```
Imports ‚Äì Keep imports at the top of the file and use separate lines.

```python
import os
import sys
```
Whitespace Usage ‚Äì Avoid unnecessary spaces in expressions.

```
# ‚úÖ Correct:
x = (a + b) * (c + d)

# ‚ùå Incorrect:
x = ( a+b ) * ( c + d )
```
Use Docstrings ‚Äì Write docstrings to explain modules, classes, and functions.

```python
def greet(name):
    """Return a greeting message."""
    return f"Hello, {name}!"

```
---

9. ### What is an interpreted language 
An **interpreted language** is a programming language where the **code is executed line by line** by an **interpreter** instead of being compiled into machine code before execution. This means that the program does not need a separate compilation step, making development and debugging faster.



#### üîπ **How Does an Interpreted Language Work?**  
1. The **interpreter** reads the source code **line by line**.  
2. Each line is **translated into machine code** and executed immediately.  
3. If an error is found, execution stops at that line (instead of compiling the entire program first).  

**Example: Running Python Code Directly**


python my_script.py
Unlike compiled languages like C or Java, **Python does not require a separate compilation** step before execution.

#### üîπ Interpreted vs Compiled Languages
| Feature |	Interpreted Language (Python) |	Compiled Language (C, Java) |
| ------- | ----------------------------- | --------------------------- |
| Execution | 	Line by line  | Whole program at once |
| Speed	    |Slower (extra translation step)|	Faster (precompiled)|
|Debugging	|Easier (stops at the error line)	|Harder (must recompile)|
|Portability	|More portable (runs anywhere with an interpreter)	|Must be compiled per system|
|Examples	|Python, JavaScript, Ruby	|C, C++, Java
##### üîπ Examples of Interpreted Languages
‚úÖ Python ‚Äì Uses the Python interpreter (CPython, PyPy).
‚úÖ JavaScript ‚Äì Runs inside web browsers (Chrome‚Äôs V8 engine).
‚úÖ Ruby ‚Äì Uses MRI (Matz's Ruby Interpreter).
‚úÖ PHP ‚Äì Runs on web servers with Zend Engine.
 
##### üîπ Advantages of Interpreted Languages
‚úî Cross-platform ‚Äì Code runs on any system with an interpreter.
‚úî Faster development ‚Äì No need to compile before execution.
‚úî Easier debugging ‚Äì Errors are detected at runtime.

##### üîπ Disadvantages of Interpreted Languages
‚ùå Slower execution ‚Äì Extra step of translating code at runtime.
‚ùå Higher resource usage ‚Äì Uses more memory and CPU compared to compiled languages.

- Python as a language is not interpreted or compiled. Interpreted or compiled is the property of the implementation. Python is a bytecode(set of interpreter readable instructions) interpreted generally.
- Source code is a file with .py extension.
- Python compiles the source code to a set of instructions for a virtual machine. The Python interpreter is an implementation of that virtual machine. This intermediate format is called ‚Äúbytecode‚Äù.
- .py source code is first compiled to give .pyc which is bytecode. This bytecode can be then interpreted by the official CPython or JIT(Just in Time compiler) compiled by PyPy.

---
10. ### What is the difference between a compiled and an interpreted language

Programming languages can be classified into **compiled** and **interpreted** languages based on how their code is executed.



#### üîπ **Compiled Language**  
A **compiled language** translates the entire source code into machine code **before execution**. The resulting executable file can run independently **without requiring the original source code**.  

üîπ **How it Works:**  
1. The compiler converts the entire program into machine code.  
2. The generated executable file can run multiple times without recompilation.  
3. Compilation must be done separately for different operating systems.  

üîπ **Examples of Compiled Languages:**  
‚úÖ C, C++ (Compiled using `gcc`, `clang`, `MSVC`)  
‚úÖ Java (Compiles to bytecode, then interpreted by JVM)  
‚úÖ Go, Rust  

üîπ **Advantages:**  
‚úî **Faster execution** (no need to translate at runtime)  
‚úî **More optimized code** (compilers optimize performance)  
‚úî **Better security** (source code is not needed to run the program)  

üîπ **Disadvantages:**  
‚ùå **Slower development cycle** (compilation required before execution)  
‚ùå **Less portability** (compiled code is specific to an OS/architecture)  




#### üîπ **Interpreted Language**  
An **interpreted language** executes code **line by line at runtime** using an **interpreter** instead of compiling it beforehand.  

üîπ **How it Works:**  
1. The interpreter reads and translates code **one line at a time**.  
2. Execution stops immediately if an error is encountered.  
3. The same code can run across different systems **without recompilation**.  

üîπ **Examples of Interpreted Languages:**  
‚úÖ Python (CPython, PyPy interpreters)  
‚úÖ JavaScript (Chrome‚Äôs V8 Engine, Node.js)  
‚úÖ Ruby, PHP, Bash  

üîπ **Advantages:**  
‚úî **Faster development** (no need to compile before running)  
‚úî **Platform-independent** (runs on any OS with an interpreter)  
‚úî **Easier debugging** (stops at the error line)  

üîπ **Disadvantages:**  
‚ùå **Slower execution** (each line is translated on the fly)  
‚ùå **More resource-intensive** (needs an interpreter at runtime)  

---

#### üîπ **Comparison Table**  

| Feature              | Compiled Language (C, C++) | Interpreted Language (Python, JS) |
|----------------------|--------------------------|----------------------------------|
| **Execution**       | Entire program at once   | Line by line (runtime)          |
| **Speed**          | ‚ö° **Faster** (precompiled) | üê¢ **Slower** (extra translation) |
| **Portability**     | ‚ùå OS-specific binary | ‚úÖ Runs on any system with an interpreter |
| **Debugging**       | Harder (must recompile after fixing errors) | Easier (stops at the error) |
| **Example Usage**   | System programming, high-performance apps | Scripting, web development |



### üéØ **Conclusion**
- **Use compiled languages (C, C++, Rust)** when you need **high performance** and optimized code.  
- **Use interpreted languages (Python, JavaScript)** when you need **flexibility, cross-platform support, and faster development cycles**. üöÄ  

---
11. ### How to check the Python version on your system 

To check which version of Python is installed on your system, you can use the **command line (terminal, CMD, or PowerShell)**.



#### üîπ **Check Python Version in Command Line**  
Run the following command:  

```sh
python --version
```
---
12. ### What are keywords in Python  

**Keywords** in Python are **reserved words** that have **predefined meanings** and **cannot be used as variable names, function names, or any other identifiers**. They are an essential part of Python's syntax and help define the structure of the language.



#### üîπ **List of Python Keywords**  
Python has a set of built-in keywords. You can view them using the following command in Python:

```python
import keyword
print(keyword.kwlist)
```
##### Example output Python(3.10)
```python
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 
'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 
'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 
'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 
'while', 'with', 'yield']


```
##### Examples of keyword usage in python
```python
# Using 'if', 'elif', 'else' (Conditional statements)
x = 10
if x > 5:
    print("x is greater than 5")
elif x == 5:
    print("x is equal to 5")
else:
    print("x is less than 5")

# Output:
# x is greater than 5

# Using 'for' and 'in' (Looping)
for i in range(3):
    print(i)

# Output:
# 0
# 1
# 2

# Using 'def' to define a function
def greet():
    return "Hello, Python!"
print(greet())

# Output:
# Hello, Python!

# Using 'class' to define a class
class Animal:
    pass

# No output (class is just defined)

# Using 'try', 'except' for exception handling
try:
    y = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")

# Output:
# Cannot divide by zero!

``` 
---
13. ### What is indentation, and why is it important in Python

**Indentation** in Python refers to the **spaces or tabs used at the beginning of a line** to define the structure of code blocks. Unlike other programming languages that use curly braces `{}` to define blocks, Python **strictly requires indentation** to determine the hierarchy of statements.



#### üîπ **Why is Indentation Important in Python?**  
‚úî **Defines Code Blocks** ‚Äì Python uses indentation instead of `{}` to mark code blocks.  
‚úî **Enhances Readability** ‚Äì Proper indentation makes the code easier to read and understand.  
‚úî **Prevents Syntax Errors** ‚Äì Incorrect indentation results in an `IndentationError`.  



#### üîπ **Example of Correct Indentation**
```python
def greet(name):
    if name:
        print(f"Hello, {name}!")  # Indented block inside if-statement
    else:
        print("Hello, Stranger!")  # Indented block inside else-statement

greet("Alice")

# Output:
# Hello, Alice!
```
#### üîπ Example of Incorrect Indentation
```python
def greet(name):
if name:  # ‚ùå Incorrect indentation
print(f"Hello, {name}!")  # ‚ùå This will cause an IndentationError
else:
print("Hello, Stranger!")  # ‚ùå Incorrect indentation

```
#### output
```python
IndentationError: expected an indented block
```
#### üîπ Python‚Äôs Indentation Rules
‚úî Use 4 spaces per indentation level (recommended by PEP 8)
‚úî Be consistent ‚Äì Do not mix spaces and tabs
‚úî Every block must have the same indentation level

üéØ Conclusion
Indentation is not just for code formatting in Python; it is required for defining code structure. Incorrect indentation leads to errors, so following PEP 8 guidelines (4 spaces per indentation level) ensures clean, readable, and error-free code. üöÄ

---
14. ### What is the difference between `==` and `=` in Python  

In Python, `=` and `==` serve completely different purposes:  

| Operator  | Purpose |
|-----------|---------|
| `=` (Single Equals)  | Assignment Operator ‚Äì Used to assign values to variables. |
| `==` (Double Equals) | Comparison Operator ‚Äì Used to check if two values are equal. |



#### üîπ **Example of `=` (Assignment Operator)**  
The **`=` operator** assigns a value to a variable.  
```python
x = 10  # Assigns 10 to variable x
y = "Python"  # Assigns "Python" to variable y

print(x)  
print(y)

# Output:
# 10
# Python
```
---
15. ### How can you print without a newline in Python  

By default, the `print()` function in Python **adds a newline (`n`) at the end** of the output. To **print without a newline**, use the `end` parameter of `print()`.



#### üîπ **Example: Printing Without a Newline**  
```python
print("Hello", end=" ")
print("World")

# Output:
# Hello World
```
‚úÖ The end=" " argument replaces the default newline n with a space, so the two print() statements output text on the same line

#### üîπ Example: Printing Multiple Items in a Single Line
```python
print("Python", end=" - ")
print("Programming", end=" - ")
print("Language")

# Output:
# Python - Programming - Language

```
‚úÖ Here, end=" - " adds a hyphen and space (-) instead of a newline.

#### üîπ Example: Printing Without Any Spaces or Newlines
```python
print("Hello", end="")
print("World")

# Output:
# HelloWorld

```
‚úÖ Since end="" removes the default newline without adding any space, the words are printed together.

**üéØ Conclusion**
‚úÖ By default, print() adds a newline after printing.

‚úÖ Use print("text", end=" ") to replace newline with a space or any character.

‚úÖ Use end="" to print without any space or newline. üöÄ

[Back to Top](#table-of-content) 
---
16. ### What are variables in Python  

A **variable** in Python is a **named storage location** used to store data. It acts as a container that holds values, which can be changed during program execution.



#### üîπ **Declaring and Assigning Variables**  
In Python, you don't need to declare the type of a variable explicitly. It is dynamically inferred based on the value assigned.

```python
x = 10         # Integer variable
name = "Alice" # String variable
pi = 3.14      # Float variable
is_valid = True # Boolean variable

print(x)      
print(name)    
print(pi)     
print(is_valid)  

# Output:
# 10
# Alice
# 3.14
# True
```

**üîπ Variable Naming Rules**
‚úî Must start with a letter (a-z, A-Z) or underscore _
‚úî Cannot start with a number (e.g., ```1var``` is invalid)
‚úî Can only contain letters, digits, and underscores
‚úî Case-sensitive (```myVar``` and ```myvar``` are different)
‚úî Cannot be a Python keyword (```def```, ```if```, ```else```, ```etc```.)

**‚úÖ Valid Variable Names**
```python
age = 25
_name = "John"
user123 = "Python"

```
**‚ùå Invalid Variable Names**
```python
1name = "Alice"  # ‚ùå Cannot start with a number
my-name = "Bob"  # ‚ùå Hyphens are not allowed
def = 10         # ‚ùå Cannot use keywords

```
**üîπ Reassigning Variables**
You can change the value of a variable at any time:

```python
x = 5
print(x)  # Output: 5

x = "Hello"
print(x)  # Output: Hello
```
‚úÖ Python allows **changing data types** because it is **dynamically typed**.

**üéØ Conclusion**
‚úÖ **Variables store values** that can change during execution.

‚úÖ **Python is dynamically typed**, so variable types are inferred.

‚úÖ **Follow naming rules** to avoid syntax errors. üöÄ


---
17. ### What is Dynamic Typing in Python


#### **Definition**

Dynamic typing means that the type of a variable is determined at runtime rather than being explicitly declared. In Python, you do not need to specify the data type of a variable when declaring it. The interpreter assigns the type based on the value assigned to the variable.


#### **How Dynamic Typing Works**

In Python, a variable can hold different types of values at different times. The same variable can be reassigned to a different data type without any explicit type conversion.


#### ***Example of Dynamic Typing in Python***


```python
x = 10      # x is an integer
print(type(x))  

x = "Hello" # x is now a string
print(type(x))  

x = 3.14    # x is now a float
print(type(x))  
```


Output:


```
<class 'int'>
<class 'str'>
<class 'float'>
```


The variable `x` starts as an integer, then becomes a string, and finally a float.


#### **Advantages of Dynamic Typing**



* **Flexibility** ‚Äì Variables can change types based on assigned values. 

* **Faster development** ‚Äì No need to declare variable types explicitly. 

* **Memory efficiency** ‚Äì Python automatically manages memory allocation. 



#### **Disadvantages of Dynamic Typing**



* **Type errors at runtime ‚Äì** A variable can change type unexpectedly, leading to errors. 

* **Slower execution ‚Äì** Extra processing is required to determine types at runtime. 



#### Example of a Type Error Due to Dynamic Typing


```
x = "10"  # String
y = 5
print(x + y)  # ‚ùå TypeError: can only concatenate str (not "int") to str
```


Solution: Convert `x` to an integer before performing addition:


```
print(int(x) + y)  # ‚úÖ Output: 15
```


#### **Conclusion**

Dynamic typing allows flexibility and ease of coding, making Python highly versatile. However, it requires careful handling to avoid unexpected type errors.

---

18. ### What are built-in data types in Python  
#### **Built-in Data Types in Python (Detailed Explanation)**

Python provides a variety of **built-in data types** to store and manipulate different kinds of data efficiently. These data types are categorized into **Immutable Data Types** (which cannot be changed after creation) and **Mutable Data Types** (which can be modified after creation).

#### **Immutable Data Types**


#### **1. int (Integer)**

The `int` data type is used to represent whole numbers (both positive and negative) without any decimal point. It supports mathematical operations like addition, subtraction, multiplication, and division.



* **Example:**


```python
x = 42
y = -10
print(type(x), type(y))  # Output: <class 'int'> <class 'int'>

```



* **Use Case:** Used in counting, indexing, loops, and arithmetic calculations. 

#### **2. float (Floating-Point Number)**

The `float` data type represents numbers with decimal points. It is commonly used for calculations that require precision, such as scientific and financial computations.



* **Example:**


```python
pi = 3.14
negative_float = -0.01
print(type(pi))  # Output: <class 'float'>

```

* **Use Case:** Used in temperature measurement, percentage calculations, and statistical data processing. 

#### **3. complex (Complex Numbers)**

Python supports complex numbers, consisting of a **real** and **imaginary** part, represented as `a + bj`, where `j` is the imaginary unit.

* **Example:**


```python
z = 3 + 4j
print(type(z))  # Output: <class 'complex'>

```



* **Use Case:** Used in mathematical computations involving imaginary numbers, such as electrical engineering and signal processing. 


#### **4. bool (Boolean)**

The `bool` type represents **True** or **False** values, which are used for logical operations and conditions.

* **Example:**

```python
is_python_fun = True
print(type(is_python_fun))  # Output: <class 'bool'>

```



* **Use Case:** Used in decision-making (if-else statements), logical conditions, and comparisons. 

#### **5. str (String)**

A `str` represents a **sequence of Unicode characters** enclosed in single, double, or triple quotes.

* **Example:**


```python
greeting = "Hello, World!"
print(type(greeting))  # Output: <class 'str'>

```



* **Use Case:** Used in text processing, data storage, and user interactions. 

#### **6. tuple (Tuple)**

A `tuple` is an **ordered** collection of elements that is **immutable** (cannot be changed after creation).
* **Example:**


```python
coordinates = (10, 20, 30)
print(type(coordinates))  # Output: <class 'tuple'>

```
* **Use Case:** Used when a fixed collection of items is needed, such as days of the week or geographical coordinates. 

#### **7. frozenset (Immutable Set)**

A `frozenset` is an **unordered** collection of unique elements that **cannot be modified** after creation.
* **Example:**


```python
frozen_numbers = frozenset([1, 2, 3, 4, 5])
print(type(frozen_numbers))  # Output: <class 'frozenset'>

```
* **Use Case:** Used in scenarios where a set must remain constant, such as defining unchangeable configuration values.

#### **8. bytes (Byte Data Type)**

The `bytes` type represents a sequence of **immutable** 8-bit bytes, often used in binary data manipulation.
* **Example:**


```python
byte_data = b"hello"
print(type(byte_data))  # Output: <class 'bytes'>

```



* **Use Case:** Used in file handling, network communication, and cryptographic operations. 
#### **9. bytearray (Mutable Byte Data Type)**

A `bytearray` is similar to `bytes`, but it **allows modification** of byte values.



* **Example:**


```python
mutable_bytes = bytearray(5)
print(type(mutable_bytes))  # Output: <class 'bytearray'>

```



* **Use Case:** Used in applications that require modification of binary data, such as image or audio processing. 


#### **10. NoneType (None Value)**

`NoneType` represents the **absence of a value** and is commonly used as a default return value for functions that do not explicitly return anything.



* **Example:**


```python
x = None
print(type(x))  # Output: <class 'NoneType'>

```
* **Use Case:** Used in functions, placeholders, and optional values in variables. 

## **Mutable Data Types**


#### **1. list (List)**

A `list` is an **ordered and mutable** collection that can store different data types.



* **Example:**


```python
fruits = ["apple", "banana", "cherry"]
fruits.append("orange")
print(type(fruits))  # Output: <class 'list'>

```

* **Use Case:** Used when a dynamic collection of elements is needed, such as storing user inputs or database records. 

#### **2. set (Set)**

A `set` is an **unordered** collection of **unique** elements.

* **Example:**

```python
unique_numbers = {1, 2, 3, 4}
print(type(unique_numbers))  # Output: <class 'set'>

```

* **Use Case:** Used for mathematical operations like union, intersection, and removing duplicates. 

#### **3. dict (Dictionary)**

A `dict` stores **key-value pairs**, making it easy to retrieve values based on keys.

* **Example:**


```python
student = {"name": "Alice", "age": 20}
print(type(student))  # Output: <class 'dict'>

```
* **Use Case:** Used in APIs, configuration files, and structured data storage. 

#### **4. memoryview (Memory Management)**

The `memoryview` type allows direct manipulation of binary data without copying it.



* **Example:**

```python
data = memoryview(bytes(5))
print(type(data))  # Output: <class 'memoryview'>

```



* **Use Case:** Used in high-performance computing for efficient memory management. 



#### **5. array (Array)**

An `array` stores elements of the **same data type** (requires `array` module).



* **Example:**


```python
import array
arr = array.array('i', [1, 2, 3, 4])
print(type(arr))  # Output: <class 'array.array'>

```

* **Use Case:** Used in performance-sensitive applications requiring homogeneous data. 

#### **6. deque (Double-Ended Queue)**

A `deque` (double-ended queue) allows **fast insertion and removal** from both ends.

* **Example:**
```python
from collections import deque
dq = deque([1, 2, 3, 4])
print(type(dq))  # Output: <class 'collections.deque'>

```
* **Use Case:** Used in queue-based applications and sliding window problems. 

#### **7. object (Base Class)**

`object` is the base class from which all Python classes inherit.

* **Example:**
```python
class Sample:
    pass

obj = Sample()
print(type(obj))  # Output: <class '__main__.Sample'>

```
* **Use Case:** Used as a foundation for creating new classes. 
#### **8. types.SimpleNamespace (Dynamic Attribute Assignment)**

Allows dynamic assignment of attributes.

* **Example:**
```python
from types import SimpleNamespace
person = SimpleNamespace(name="John", age=30)
print(type(person))  # Output: <class 'types.SimpleNamespace'>
```
* **Use Case:** Used in object-like structures with dynamic properties. 

#### **Conclusion**

Understanding **Python‚Äôs built-in data types** allows for **efficient programming** and **better memory management**. Choosing the right data type improves **code performance, readability, and maintainability**.

---
19. ### What is Type Casting in Python

Type casting in Python refers to **converting a variable from one data type to another**. This is useful when performing operations that require a specific data type. Python provides two types of type casting:



1. **Implicit Type Casting (Automatic Conversion)**
2. **Explicit Type Casting (Manual Conversion)**




#### **1. Implicit Type Casting**


Python **automatically converts** a smaller data type to a larger one when required, without any user intervention. This prevents data loss.


#### **Example:**


```python
    a = 5    # int
    b = 2.5  # float
    result = a + b  # int + float ‚Üí float
    print(result, type(result))  
    # Output: 7.5 <class 'float'>
```


**Explanation:**



* `a` (int) is automatically converted to `float` before addition. 

* The result is a `float`, ensuring no data loss. 


**Use Case:**



* When performing arithmetic operations between different numeric types. 





#### **2. Explicit Type Casting**


Explicit type casting is when we **manually** convert a variable from one type to another using Python‚Äôs built-in functions.


#### **Common Type Casting Functions in Python:**

| Function    | Description                                      | Example                 | Output  |
|------------|--------------------------------------------------|-------------------------|---------|
| `int(x)`   | Converts `x` to an integer.                     | `int(3.7)`              | `3`     |
| `float(x)` | Converts `x` to a floating-point number.        | `float(5)`              | `5.0`   |
| `str(x)`   | Converts `x` to a string.                      | `str(10)`               | `'10'`  |
| `bool(x)`  | Converts `x` to a boolean value.                | `bool(0)`               | `False` |
| `list(x)`  | Converts `x` to a list.                         | `list((1, 2, 3))`       | `[1,2,3]` |
| `tuple(x)` | Converts `x` to a tuple.                        | `tuple([4, 5, 6])`      | `(4,5,6)` |
| `set(x)`   | Converts `x` to a set (unique elements only).   | `set([1, 2, 2, 3])`     | `{1,2,3}` |
| `dict(x)`  | Converts `x` to a dictionary (from key-value pairs). | `dict([(1, 'a'), (2, 'b')])` | `{1: 'a', 2: 'b'}` |
| `complex(x, y)` | Converts `x` and `y` into a complex number. | `complex(2, 3)` | `(2+3j)` |



#### **Example 1: Converting Float to Integer**


```python
    num = 5.9
    int_num = int(num)  
    print(int_num, type(int_num))  
    # Output: 5 <class 'int'>
```


**Explanation:**



* The decimal part is removed, leaving only the integer value. 


**Use Case:**



* Used when whole numbers are needed, such as array indexing. 


---


#### **Example 2: Converting Integer to String**


```python
num = 100
str_num = str(num)  
print(str_num, type(str_num))  
# Output: '100' <class 'str'>

```


**Explanation:**


* The integer `100` is converted to a string `'100'`. 


**Use Case:**



* Useful when concatenating numbers with text. 


#### **Example 3: Converting String to Integer**


```python
num_str = "50"
num_int = int(num_str)  
print(num_int + 10)  
# Output: 60

```


**Explanation:**

* The string `"50"` is converted into an integer `50`, enabling arithmetic operations. 

**Use Case:**

* Often used when receiving user input, which is always a string by default. 


#### **Example 4: Converting List to Tuple**


```python
my_list = [1, 2, 3]
my_tuple = tuple(my_list)  
print(my_tuple, type(my_tuple))  
# Output: (1, 2, 3) <class 'tuple'>
```


**Explanation:**



* The list `[1, 2, 3]` is converted into a tuple `(1, 2, 3)`. 


**Use Case:**



* Used when an immutable version of a list is required. 





#### **Summary**

* **Implicit Type Casting**: Python automatically converts smaller types to larger types. 

* **Explicit Type Casting**: The user manually converts types using built-in functions. 

* Type casting is useful for **ensuring compatibility** in operations and handling user input correctly.

[Back to Top](#table-of-content) 
---
20. ### What are global and local variables


In Python, **variables have scope**, which determines where a variable can be accessed. Variables can be **global** or **local**, depending on where they are declared.


#### **Local Variables**

A **local variable** is declared **inside a function** and can only be used within that function. It is created when the function is called and destroyed when the function execution is complete.

**Example:**


```python
def my_function():
    x = 10  # Local variable
    print("Inside function:", x)

my_function()
   # print(x)  # This would cause an error because 'x' is local to     the function.
```


**Output:**


```python
Inside function: 10
```


*(Trying to access x outside the function would cause an error.)*


#### **Global Variables**

A **global variable** is declared **outside any function** and can be accessed throughout the program.

**Example:**


```python
y = 20  # Global variable
def another_function():
        print("Inside function:", y)  # Accessible inside the function
another_function()
    print("Outside function:", y)  # Also accessible outside
```


**Output:**

```python
Inside function: 20

Outside function: 20
```


*(The variable y is accessible inside and outside the function.)*




#### **Using global  Keyword**

If a function needs to modify a global variable, the globall keyword must be used.

**Example:**


```python
    z = 5  # Global variable

    def modify_global():
        global z  # Declaring z as a global variable
        z = 15  # Modifying the global variable

    modify_global()
    print("Updated global variable:", z)
```


**Output**


```python
    Updated global variable: 15
```


*(The global variable z  is modified inside the function using the global keyword.)*

#### Key Differences Between Local and Global Variables
| Feature            | Local Variable                  | Global Variable                   |
|--------------------|--------------------------------|----------------------------------|
| **Declared Inside** | A function                     | Outside any function            |
| **Scope**         | Only within the function       | Entire program                  |
| **Lifetime**      | Created when function is called, destroyed when function ends | Exists as long as the program runs |
| **Access Outside Function** | ‚ùå No (Causes an error) | ‚úÖ Yes (Accessible everywhere) |
| **Modification Inside Function** | Possible without `global` keyword | Requires `global` keyword |


