
### Table of content
<!-- TOC_START -->
| No. | Questions |
| --- | --------- |
| 1 | [What is Python?](#what-is-python) |
| 2 | [Why is Python so popular?](#why-is-python-so-popular) |
| 3 | [How to install Python?](#how-to-install-python) |
| 4 | [What are the applications of Python?](#what-are-the-applications-of-python) |
| 5 | [What are the advantages of Python?](#what-are-the-advantages-of-python) |
| 6 | [What are the limitations of Python?](#what-are-the-limitations-of-python) |
| 7 | [What are literals in Python?](#what-are-literals-in-python) |
| 8 | [What is PEP 8, and why is it important?](#what-is-pep-8-and-why-is-it-important) |
| 9 | [What is an interpreted language?](#what-is-an-interpreted-language) |
| 10 | [What is the difference between a compiled and an interpreted language?](#what-is-the-difference-between-a-compiled-and-an-interpreted-language) |
| 11 | [How to check the Python version on your system?](#how-to-check-the-python-version-on-your-system) |
| 12 | [What are keywords in Python?](#what-are-keywords-in-python) |
| 13 | [What is indentation, and why is it important in Python?](#what-is-indentation-and-why-is-it-important-in-python) |
| 14 | [What is the difference between == and = in Python?](#what-is-the-difference-between-==-and-=-in-python) |
| 15 | [How can you print without a newline in Python?](#how-can-you-print-without-a-newline-in-python) |
| 16 | [What are variables in Python?](#what-are-variables-in-python) |
| 17 | [What is dynamic typing in Python?](#what-is-dynamic-typing-in-python) |
| 18 | [What are built-in data types in Python?](#what-are-built-in-data-types-in-python) |
| 19 | [What is type casting in Python?](#what-is-type-casting-in-python) |
| 20 | [What are global and local variables?](#what-are-global-and-local-variables) |
| 21 | [What is the difference between a list and a tuple?](#what-is-the-difference-between-a-list-and-a-tuple) |
| 22 | [How do you create a tuple with one element?](#how-do-you-create-a-tuple-with-one-element) |
| 23 | [What is tuple unpacking?](#what-is-tuple-unpacking) |
| 24 | [How do you concatenate two lists in Python?](#how-do-you-concatenate-two-lists-in-python) |
| 25 | [What is a dictionary in Python?](#what-is-a-dictionary-in-python) |
| 26 | [How do you access elements in a dictionary?](#how-do-you-access-elements-in-a-dictionary) |
| 27 | [What is the difference between pop() and remove() in lists?](#what-is-the-difference-between-pop-and-remove-in-lists) |
| 28 | [What is the difference between append() and extend() in lists?](#what-is-the-difference-between-append-and-extend-in-lists) |
| 29 | [What is a set in Python?](#what-is-a-set-in-python) |
| 30 | [What is the difference between a set and a frozenset?](#what-is-the-difference-between-a-set-and-a-frozenset) |
| 31 | [What is a string in Python?](#what-is-a-string-in-python) |
| 32 | [How do you reverse a string in Python?](#how-do-you-reverse-a-string-in-python) |
| 33 | [What is string interpolation?](#what-is-string-interpolation) |
| 34 | [What is an f-string?](#what-is-an-f-string) |
| 35 | [How can you split a string into a list?](#how-can-you-split-a-string-into-a-list) |
| 36 | [How do you check if a string contains a substring?](#how-do-you-check-if-a-string-contains-a-substring) |
| 37 | [How do you replace a substring in a string?](#how-do-you-replace-a-substring-in-a-string) |
| 38 | [What is string slicing?](#what-is-string-slicing) |
| 39 | [What are negative indices in Python?](#what-are-negative-indices-in-python) |
| 40 | [What is the difference between str() and repr()?](#what-is-the-difference-between-str-and-repr) |
| 41 | [What are list comprehensions?](#what-are-list-comprehensions) |
| 42 | [What is the difference between list comprehension and a loop?](#what-is-the-difference-between-list-comprehension-and-a-loop) |
| 43 | [What are generators in Python?](#what-are-generators-in-python) |
| 44 | [What is the yield keyword?](#what-is-the-yield-keyword) |
| 45 | [What is a lambda function?](#what-is-a-lambda-function) |
| 46 | [What is the difference between map() and filter()?](#what-is-the-difference-between-map-and-filter) |
| 47 | [What is the difference between map() and list comprehension?](#what-is-the-difference-between-map-and-list-comprehension) |
| 48 | [What is the use of the zip() function?](#what-is-the-use-of-the-zip-function) |
| 49 | [What is a function in Python?](#what-is-a-function-in-python) |
| 50 | [How do you define a function in Python?](#how-do-you-define-a-function-in-python) |
| 51 | [What is a docstring?](#what-is-a-docstring) |
| 52 | [What is the difference between a function and a method?](#what-is-the-difference-between-a-function-and-a-method) |
| 53 | [What are default arguments?](#what-are-default-arguments) |
| 54 | [What are positional arguments?](#what-are-positional-arguments) |
| 55 | [What are keyword arguments?](#what-are-keyword-arguments) |
| 56 | [What are *args and **kwargs?](#what-are-args-and-kwargs) |
| 57 | [What is recursion in Python?](#what-is-recursion-in-python) |
| 58 | [What is the base case in recursion?](#what-is-the-base-case-in-recursion) |
| 59 | [How to avoid infinite recursion?](#how-to-avoid-infinite-recursion) |
| 60 | [What is a module in Python?](#what-is-a-module-in-python) |
| 61 | [How do you import a module?](#how-do-you-import-a-module) |
| 62 | [What is the difference between import and from import?](#what-is-the-difference-between-import-and-from-import) |
| 63 | [What is the __name__ variable?](#what-is-the-__name__-variable) |
| 64 | [What is the purpose of if __name__ == '__main__':?](#what-is-the-purpose-of-if-__name__--main) |
| 65 | [What are packages in Python?](#what-are-packages-in-python) |
| 66 | [What is the purpose of the __init__.py file?](#what-is-the-purpose-of-the-__init__.py-file) |
| 67 | [How do you install external packages using pip?](#how-do-you-install-external-packages-using-pip) |
| 68 | [What is file handling in Python?](#what-is-file-handling-in-python) |
| 69 | [How do you open a file in Python?](#how-do-you-open-a-file-in-python) |
| 70 | [What are the different file modes in Python?](#what-are-the-different-file-modes-in-python) |
| 71 | [How do you read from a file?](#how-do-you-read-from-a-file) |
| 72 | [How do you write to a file?](#how-do-you-write-to-a-file) |
| 73 | [How do you close a file?](#how-do-you-close-a-file) |
| 74 | [What is the with statement in file handling?](#what-is-the-with-statement-in-file-handling) |
| 75 | [What is exception handling?](#what-is-exception-handling) |
| 76 | [What are try, except, else, and finally blocks?](#what-are-try-except-else-and-finally-blocks) |
| 77 | [What is the difference between syntax errors and exceptions?](#what-is-the-difference-between-syntax-errors-and-exceptions) |
| 78 | [How do you raise an exception?](#how-do-you-raise-an-exception) |
| 79 | [What is the assert statement in Python?](#what-is-the-assert-statement-in-python) |
| 80 | [What is the purpose of the raise keyword?](#what-is-the-purpose-of-the-raise-keyword) |
| 81 | [What are built-in exceptions in Python?](#what-are-built-in-exceptions-in-python) |
| 82 | [How can you create a custom exception?](#how-can-you-create-a-custom-exception) |
| 83 | [What is a class in Python?](#what-is-a-class-in-python) |
| 84 | [What is an object in Python?](#what-is-an-object-in-python) |
| 85 | [How do you create a class?](#how-do-you-create-a-class) |
| 86 | [What is the __init__ method?](#what-is-the-__init__-method) |
| 87 | [What is self in Python?](#what-is-self-in-python) |
| 88 | [What are class variables and instance variables?](#what-are-class-variables-and-instance-variables) |
| 89 | [What is inheritance in Python?](#what-is-inheritance-in-python) |
| 90 | [What is single inheritance?](#what-is-single-inheritance) |
| 91 | [What is multiple inheritance?](#what-is-multiple-inheritance) |
| 92 | [What is multi-level inheritance?](#what-is-multi-level-inheritance) |
| 93 | [What is hybrid inheritance?](#what-is-hybrid-inheritance) |
| 94 | [What is polymorphism?](#what-is-polymorphism) |
| 95 | [What is method overloading?](#what-is-method-overloading) |
| 96 | [What is method overriding?](#what-is-method-overriding) |
| 97 | [What is encapsulation?](#what-is-encapsulation) |
| 98 | [What is abstraction?](#what-is-abstraction) |
| 99 | [What are access modifiers in Python?](#what-are-access-modifiers-in-python) |
| 100 | [What is the difference between public, protected, and private members?](#what-is-the-difference-between-public-protected-and-private-members) |



1. ### What is Python

Python is a **high-level, interpreted, and dynamically typed** programming language. It is known for its **simplicity, readability, and ease of use**. Python supports multiple programming paradigms, including **procedural, object-oriented, and functional programming**.  

It is widely used in various fields, such as:  
- **Web Development** (Django, Flask)  
- **Data Science & Machine Learning** (Pandas, NumPy, Scikit-learn)  
- **Automation & Scripting**  
- **Cybersecurity & Ethical Hacking**  
- **Embedded Systems & IoT**  

Python is also **cross-platform** and has a **large standard library**, making it one of the most popular programming languages today. 🚀  

---

2. ### Why is Python so popular 

Python is popular due to its **simplicity, versatility, and strong community support**. Some key reasons for its popularity include:  

- **Easy-to-read syntax** – Python code is simple and resembles natural language, making it beginner-friendly.  
- **Large standard library** – Comes with built-in modules for various tasks like file handling, networking, and databases.  
- **Cross-platform compatibility** – Runs on Windows, macOS, and Linux without modification.  
- **Wide range of applications** – Used in web development, data science, AI, automation, and more.  
- **Strong community support** – A vast number of tutorials, forums, and third-party libraries make development easier.  
- **Extensive third-party packages** – Tools like NumPy, Pandas, and TensorFlow extend Python’s functionality.  

Due to these features, Python is widely used in **software development, data analysis, artificial intelligence, and automation**. 🚀  

---
3. ### How to install Python
---
4. ### What are the applications of Python 

Python is a **versatile** programming language used in various fields due to its **simplicity, flexibility, and extensive libraries**. Some of the major applications of Python include:  

- **Web Development** – Frameworks like Django and Flask are used to build dynamic and scalable web applications.  
- **Data Science & Analytics** – Libraries such as Pandas, NumPy, and Matplotlib help in data processing and visualization.  
- **Machine Learning & AI** – TensorFlow, Scikit-learn, and PyTorch enable the development of intelligent applications.  
- **Automation & Scripting** – Python automates repetitive tasks, such as file handling, data entry, and web scraping.  
- **Cybersecurity & Ethical Hacking** – Security experts use Python for penetration testing and malware analysis.  
- **Game Development** – Pygame and Panda3D are used to develop 2D and 3D games.  
- **Embedded Systems & IoT** – Python is used in Raspberry Pi and Arduino-based IoT applications.  
- **Software Testing & Automation** – Selenium and PyTest help in automating software testing.  
- **Blockchain & Cryptocurrency** – Developers use Python to build blockchain-based applications.  
- **Networking** – Python is used for network programming, socket programming, and server automation.  

Python's **cross-platform compatibility** and **extensive support for third-party libraries** make it a preferred choice for various domains. 🚀  

---

5. ### What are the advantages of Python 

Python offers several advantages, making it one of the most popular programming languages today:  

- **Easy to Learn & Use** – Python has a simple syntax similar to English, making it beginner-friendly.  
- **High-Level Language** – Developers don’t need to manage memory manually.  
- **Interpreted Language** – Python executes code line by line, making debugging easier.  
- **Cross-Platform** – Python runs on multiple operating systems (Windows, macOS, Linux).  
- **Extensive Libraries & Frameworks** – Libraries like NumPy, Pandas, TensorFlow, and Django support various applications.  
- **Community Support** – A vast global community provides documentation, tutorials, and troubleshooting support.  
- **Versatile** – Python is used in web development, data science, AI, automation, cybersecurity, and more.  
- **Dynamically Typed** – No need to declare variable types explicitly.  
- **Integration & Extensibility** – Python can integrate with C, C++, Java, and other languages.  

Python’s simplicity and power make it an excellent choice for developers of all levels. 🚀

---

6. ### What are the limitations of Python  

Despite its advantages, Python has some limitations:  

- **Slower Execution Speed** – Since Python is an interpreted language, it runs slower than compiled languages like C or Java.  
- **High Memory Consumption** – Python uses more memory due to its flexible data types and dynamic typing.  
- **Global Interpreter Lock (GIL)** – Python’s GIL restricts multi-threaded execution, making it less efficient for CPU-bound tasks.  
- **Not Ideal for Mobile Development** – Python is not commonly used for mobile applications due to performance concerns.  
- **Limited Database Access** – Python’s database access layers are not as robust as those in Java or C++.  
- **Weak in Multi-Core Processing** – Due to GIL, Python struggles with parallel processing in multi-core CPUs.  
- **Dependency Management** – Managing dependencies in larger projects can be complex compared to languages like JavaScript with Node.js.  

While Python is powerful, these limitations should be considered when selecting it for a project. 🔍

[Back to Top](#table-of-content) 
---
7. ### What are literals in Python  

Literals in Python are fixed values assigned directly to variables or constants. They represent data without requiring computation. Python has different types of literals:  

#### 1. **String Literals**  
Represent text enclosed in single, double, or triple quotes.  

```python
single_quote = 'Hello'
double_quote = "Hello"
triple_quote = '''Hello, this is a multi-line string'''
```

### 2. Numeric Literals
Include integers, floating-point numbers, and complex numbers.

```python
integer_num = 10         # Integer literal
float_num = 3.14         # Float literal
complex_num = 3 + 4j     # Complex literal

```
### 3. Boolean Literals
Represent truth values: True or False.

```python
is_python_easy = True
is_java_better = False
```
### 4. Special Literal
Python provides a special literal None to indicate the absence of a value.

```python
no_value = None
```
### 5. List, Tuple, Dictionary, and Set Literals
Collections of data in different formats.

```python
list_literal = [1, 2, 3, "Python"]     # List literal
tuple_literal = (10, 20, 30)           # Tuple literal
dict_literal = {'name': 'Alice', 'age': 25}  # Dictionary literal
set_literal = {1, 2, 3, 4}             # Set literal
```
Literals make code more readable and easy to understand. 🚀


---

8. ### What is PEP 8, and why is it important

**PEP 8 (Python Enhancement Proposal 8)** is the official style guide for writing Python code. It provides guidelines to improve the readability, consistency, and maintainability of Python programs.

#### 🔹 **Why is PEP 8 important?**
- ✅ **Improves Readability** – Ensures code is easy to read and understand.
- ✅ **Encourages Consistency** – Helps developers follow the same coding conventions.
- ✅ **Enhances Collaboration** – Makes it easier for teams to work on the same codebase.
- ✅ **Industry Standard** – Many companies and open-source projects follow PEP 8.

#### 🔹 **Key PEP 8 Guidelines**
1. **Indentation** – Use **4 spaces per indentation level**.
   ```python
   def greet():
       print("Hello, World!")  # 4-space indentation
   ```
Maximum Line Length – Keep lines ≤ 79 characters for better readability.

```python
message = "This is a long line, but it should ideally be within 79 characters."
```
Blank Lines – Use 2 blank lines between top-level functions and classes.

```python
class MyClass:
    pass

def my_function():
    pass
```
Naming Conventions:

Use snake_case for variables and functions.

Use CamelCase for class names.

Use ALL_CAPS for constants.

```python
class MyClass:
    MY_CONSTANT = 100  # Constant
    
    def my_function(self):  # Function name
        my_variable = "Hello"  # Variable name
```
Imports – Keep imports at the top of the file and use separate lines.

```python
import os
import sys
```
Whitespace Usage – Avoid unnecessary spaces in expressions.

```
# ✅ Correct:
x = (a + b) * (c + d)

# ❌ Incorrect:
x = ( a+b ) * ( c + d )
```
Use Docstrings – Write docstrings to explain modules, classes, and functions.

```python
def greet(name):
    """Return a greeting message."""
    return f"Hello, {name}!"

```
---

9. ### What is an interpreted language 
An **interpreted language** is a programming language where the **code is executed line by line** by an **interpreter** instead of being compiled into machine code before execution. This means that the program does not need a separate compilation step, making development and debugging faster.



#### 🔹 **How Does an Interpreted Language Work?**  
1. The **interpreter** reads the source code **line by line**.  
2. Each line is **translated into machine code** and executed immediately.  
3. If an error is found, execution stops at that line (instead of compiling the entire program first).  

**Example: Running Python Code Directly**


python my_script.py
Unlike compiled languages like C or Java, **Python does not require a separate compilation** step before execution.

#### 🔹 Interpreted vs Compiled Languages
| Feature |	Interpreted Language (Python) |	Compiled Language (C, Java) |
| ------- | ----------------------------- | --------------------------- |
| Execution | 	Line by line  | Whole program at once |
| Speed	    |Slower (extra translation step)|	Faster (precompiled)|
|Debugging	|Easier (stops at the error line)	|Harder (must recompile)|
|Portability	|More portable (runs anywhere with an interpreter)	|Must be compiled per system|
|Examples	|Python, JavaScript, Ruby	|C, C++, Java
##### 🔹 Examples of Interpreted Languages
✅ Python – Uses the Python interpreter (CPython, PyPy).
✅ JavaScript – Runs inside web browsers (Chrome’s V8 engine).
✅ Ruby – Uses MRI (Matz's Ruby Interpreter).
✅ PHP – Runs on web servers with Zend Engine.
 
##### 🔹 Advantages of Interpreted Languages
✔ Cross-platform – Code runs on any system with an interpreter.
✔ Faster development – No need to compile before execution.
✔ Easier debugging – Errors are detected at runtime.

##### 🔹 Disadvantages of Interpreted Languages
❌ Slower execution – Extra step of translating code at runtime.
❌ Higher resource usage – Uses more memory and CPU compared to compiled languages.

- Python as a language is not interpreted or compiled. Interpreted or compiled is the property of the implementation. Python is a bytecode(set of interpreter readable instructions) interpreted generally.
- Source code is a file with .py extension.
- Python compiles the source code to a set of instructions for a virtual machine. The Python interpreter is an implementation of that virtual machine. This intermediate format is called “bytecode”.
- .py source code is first compiled to give .pyc which is bytecode. This bytecode can be then interpreted by the official CPython or JIT(Just in Time compiler) compiled by PyPy.

---
10. ### What is the difference between a compiled and an interpreted language

Programming languages can be classified into **compiled** and **interpreted** languages based on how their code is executed.



#### 🔹 **Compiled Language**  
A **compiled language** translates the entire source code into machine code **before execution**. The resulting executable file can run independently **without requiring the original source code**.  

🔹 **How it Works:**  
1. The compiler converts the entire program into machine code.  
2. The generated executable file can run multiple times without recompilation.  
3. Compilation must be done separately for different operating systems.  

🔹 **Examples of Compiled Languages:**  
✅ C, C++ (Compiled using `gcc`, `clang`, `MSVC`)  
✅ Java (Compiles to bytecode, then interpreted by JVM)  
✅ Go, Rust  

🔹 **Advantages:**  
✔ **Faster execution** (no need to translate at runtime)  
✔ **More optimized code** (compilers optimize performance)  
✔ **Better security** (source code is not needed to run the program)  

🔹 **Disadvantages:**  
❌ **Slower development cycle** (compilation required before execution)  
❌ **Less portability** (compiled code is specific to an OS/architecture)  




#### 🔹 **Interpreted Language**  
An **interpreted language** executes code **line by line at runtime** using an **interpreter** instead of compiling it beforehand.  

🔹 **How it Works:**  
1. The interpreter reads and translates code **one line at a time**.  
2. Execution stops immediately if an error is encountered.  
3. The same code can run across different systems **without recompilation**.  

🔹 **Examples of Interpreted Languages:**  
✅ Python (CPython, PyPy interpreters)  
✅ JavaScript (Chrome’s V8 Engine, Node.js)  
✅ Ruby, PHP, Bash  

🔹 **Advantages:**  
✔ **Faster development** (no need to compile before running)  
✔ **Platform-independent** (runs on any OS with an interpreter)  
✔ **Easier debugging** (stops at the error line)  

🔹 **Disadvantages:**  
❌ **Slower execution** (each line is translated on the fly)  
❌ **More resource-intensive** (needs an interpreter at runtime)  

---

#### 🔹 **Comparison Table**  

| Feature              | Compiled Language (C, C++) | Interpreted Language (Python, JS) |
|----------------------|--------------------------|----------------------------------|
| **Execution**       | Entire program at once   | Line by line (runtime)          |
| **Speed**          | ⚡ **Faster** (precompiled) | 🐢 **Slower** (extra translation) |
| **Portability**     | ❌ OS-specific binary | ✅ Runs on any system with an interpreter |
| **Debugging**       | Harder (must recompile after fixing errors) | Easier (stops at the error) |
| **Example Usage**   | System programming, high-performance apps | Scripting, web development |



### 🎯 **Conclusion**
- **Use compiled languages (C, C++, Rust)** when you need **high performance** and optimized code.  
- **Use interpreted languages (Python, JavaScript)** when you need **flexibility, cross-platform support, and faster development cycles**. 🚀  

---
11. ### How to check the Python version on your system 

To check which version of Python is installed on your system, you can use the **command line (terminal, CMD, or PowerShell)**.



#### 🔹 **Check Python Version in Command Line**  
Run the following command:  

```sh
python --version
```
---
12. ### What are keywords in Python  

**Keywords** in Python are **reserved words** that have **predefined meanings** and **cannot be used as variable names, function names, or any other identifiers**. They are an essential part of Python's syntax and help define the structure of the language.



#### 🔹 **List of Python Keywords**  
Python has a set of built-in keywords. You can view them using the following command in Python:

```python
import keyword
print(keyword.kwlist)
```
##### Example output Python(3.10)
```python
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 
'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 
'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 
'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 
'while', 'with', 'yield']


```
##### Examples of keyword usage in python
```python
# Using 'if', 'elif', 'else' (Conditional statements)
x = 10
if x > 5:
    print("x is greater than 5")
elif x == 5:
    print("x is equal to 5")
else:
    print("x is less than 5")

# Output:
# x is greater than 5

# Using 'for' and 'in' (Looping)
for i in range(3):
    print(i)

# Output:
# 0
# 1
# 2

# Using 'def' to define a function
def greet():
    return "Hello, Python!"
print(greet())

# Output:
# Hello, Python!

# Using 'class' to define a class
class Animal:
    pass

# No output (class is just defined)

# Using 'try', 'except' for exception handling
try:
    y = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")

# Output:
# Cannot divide by zero!

``` 
---
13. ### What is indentation, and why is it important in Python

**Indentation** in Python refers to the **spaces or tabs used at the beginning of a line** to define the structure of code blocks. Unlike other programming languages that use curly braces `{}` to define blocks, Python **strictly requires indentation** to determine the hierarchy of statements.



#### 🔹 **Why is Indentation Important in Python?**  
✔ **Defines Code Blocks** – Python uses indentation instead of `{}` to mark code blocks.  
✔ **Enhances Readability** – Proper indentation makes the code easier to read and understand.  
✔ **Prevents Syntax Errors** – Incorrect indentation results in an `IndentationError`.  



#### 🔹 **Example of Correct Indentation**
```python
def greet(name):
    if name:
        print(f"Hello, {name}!")  # Indented block inside if-statement
    else:
        print("Hello, Stranger!")  # Indented block inside else-statement

greet("Alice")

# Output:
# Hello, Alice!
```
#### 🔹 Example of Incorrect Indentation
```python
def greet(name):
if name:  # ❌ Incorrect indentation
print(f"Hello, {name}!")  # ❌ This will cause an IndentationError
else:
print("Hello, Stranger!")  # ❌ Incorrect indentation

```
#### output
```python
IndentationError: expected an indented block
```
#### 🔹 Python’s Indentation Rules
✔ Use 4 spaces per indentation level (recommended by PEP 8)
✔ Be consistent – Do not mix spaces and tabs
✔ Every block must have the same indentation level

🎯 Conclusion
Indentation is not just for code formatting in Python; it is required for defining code structure. Incorrect indentation leads to errors, so following PEP 8 guidelines (4 spaces per indentation level) ensures clean, readable, and error-free code. 🚀

---
14. ### What is the difference between `==` and `=` in Python  

In Python, `=` and `==` serve completely different purposes:  

| Operator  | Purpose |
|-----------|---------|
| `=` (Single Equals)  | Assignment Operator – Used to assign values to variables. |
| `==` (Double Equals) | Comparison Operator – Used to check if two values are equal. |



#### 🔹 **Example of `=` (Assignment Operator)**  
The **`=` operator** assigns a value to a variable.  
```python
x = 10  # Assigns 10 to variable x
y = "Python"  # Assigns "Python" to variable y

print(x)  
print(y)

# Output:
# 10
# Python
```
---
15. ### How can you print without a newline in Python  

By default, the `print()` function in Python **adds a newline (`n`) at the end** of the output. To **print without a newline**, use the `end` parameter of `print()`.



#### 🔹 **Example: Printing Without a Newline**  
```python
print("Hello", end=" ")
print("World")

# Output:
# Hello World
```
✅ The end=" " argument replaces the default newline n with a space, so the two print() statements output text on the same line

#### 🔹 Example: Printing Multiple Items in a Single Line
```python
print("Python", end=" - ")
print("Programming", end=" - ")
print("Language")

# Output:
# Python - Programming - Language

```
✅ Here, end=" - " adds a hyphen and space (-) instead of a newline.

#### 🔹 Example: Printing Without Any Spaces or Newlines
```python
print("Hello", end="")
print("World")

# Output:
# HelloWorld

```
✅ Since end="" removes the default newline without adding any space, the words are printed together.

**🎯 Conclusion**
✅ By default, print() adds a newline after printing.

✅ Use print("text", end=" ") to replace newline with a space or any character.

✅ Use end="" to print without any space or newline. 🚀

[Back to Top](#table-of-content) 
---
16. ### What are variables in Python  

A **variable** in Python is a **named storage location** used to store data. It acts as a container that holds values, which can be changed during program execution.



#### 🔹 **Declaring and Assigning Variables**  
In Python, you don't need to declare the type of a variable explicitly. It is dynamically inferred based on the value assigned.

```python
x = 10         # Integer variable
name = "Alice" # String variable
pi = 3.14      # Float variable
is_valid = True # Boolean variable

print(x)      
print(name)    
print(pi)     
print(is_valid)  

# Output:
# 10
# Alice
# 3.14
# True
```

**🔹 Variable Naming Rules**
✔ Must start with a letter (a-z, A-Z) or underscore _
✔ Cannot start with a number (e.g., ```1var``` is invalid)
✔ Can only contain letters, digits, and underscores
✔ Case-sensitive (```myVar``` and ```myvar``` are different)
✔ Cannot be a Python keyword (```def```, ```if```, ```else```, ```etc```.)

**✅ Valid Variable Names**
```python
age = 25
_name = "John"
user123 = "Python"

```
**❌ Invalid Variable Names**
```python
1name = "Alice"  # ❌ Cannot start with a number
my-name = "Bob"  # ❌ Hyphens are not allowed
def = 10         # ❌ Cannot use keywords

```
**🔹 Reassigning Variables**
You can change the value of a variable at any time:

```python
x = 5
print(x)  # Output: 5

x = "Hello"
print(x)  # Output: Hello
```
✅ Python allows **changing data types** because it is **dynamically typed**.

**🎯 Conclusion**
✅ **Variables store values** that can change during execution.

✅ **Python is dynamically typed**, so variable types are inferred.

✅ **Follow naming rules** to avoid syntax errors. 🚀


---
17. ### What is Dynamic Typing in Python


#### **Definition**

Dynamic typing means that the type of a variable is determined at runtime rather than being explicitly declared. In Python, you do not need to specify the data type of a variable when declaring it. The interpreter assigns the type based on the value assigned to the variable.


#### **How Dynamic Typing Works**

In Python, a variable can hold different types of values at different times. The same variable can be reassigned to a different data type without any explicit type conversion.


#### ***Example of Dynamic Typing in Python***


```python
x = 10      # x is an integer
print(type(x))  

x = "Hello" # x is now a string
print(type(x))  

x = 3.14    # x is now a float
print(type(x))  
```


Output:


```
<class 'int'>
<class 'str'>
<class 'float'>
```


The variable `x` starts as an integer, then becomes a string, and finally a float.


#### **Advantages of Dynamic Typing**



* **Flexibility** – Variables can change types based on assigned values. 

* **Faster development** – No need to declare variable types explicitly. 

* **Memory efficiency** – Python automatically manages memory allocation. 



#### **Disadvantages of Dynamic Typing**



* **Type errors at runtime –** A variable can change type unexpectedly, leading to errors. 

* **Slower execution –** Extra processing is required to determine types at runtime. 



#### Example of a Type Error Due to Dynamic Typing


```
x = "10"  # String
y = 5
print(x + y)  # ❌ TypeError: can only concatenate str (not "int") to str
```


Solution: Convert `x` to an integer before performing addition:


```
print(int(x) + y)  # ✅ Output: 15
```


#### **Conclusion**

Dynamic typing allows flexibility and ease of coding, making Python highly versatile. However, it requires careful handling to avoid unexpected type errors.

---

18. ### What are built-in data types in Python  
#### **Built-in Data Types in Python (Detailed Explanation)**

Python provides a variety of **built-in data types** to store and manipulate different kinds of data efficiently. These data types are categorized into **Immutable Data Types** (which cannot be changed after creation) and **Mutable Data Types** (which can be modified after creation).

#### **Immutable Data Types**


#### **1. int (Integer)**

The `int` data type is used to represent whole numbers (both positive and negative) without any decimal point. It supports mathematical operations like addition, subtraction, multiplication, and division.



* **Example:**


```python
x = 42
y = -10
print(type(x), type(y))  # Output: <class 'int'> <class 'int'>

```



* **Use Case:** Used in counting, indexing, loops, and arithmetic calculations. 

#### **2. float (Floating-Point Number)**

The `float` data type represents numbers with decimal points. It is commonly used for calculations that require precision, such as scientific and financial computations.



* **Example:**


```python
pi = 3.14
negative_float = -0.01
print(type(pi))  # Output: <class 'float'>

```

* **Use Case:** Used in temperature measurement, percentage calculations, and statistical data processing. 

#### **3. complex (Complex Numbers)**

Python supports complex numbers, consisting of a **real** and **imaginary** part, represented as `a + bj`, where `j` is the imaginary unit.

* **Example:**


```python
z = 3 + 4j
print(type(z))  # Output: <class 'complex'>

```



* **Use Case:** Used in mathematical computations involving imaginary numbers, such as electrical engineering and signal processing. 


#### **4. bool (Boolean)**

The `bool` type represents **True** or **False** values, which are used for logical operations and conditions.

* **Example:**

```python
is_python_fun = True
print(type(is_python_fun))  # Output: <class 'bool'>

```



* **Use Case:** Used in decision-making (if-else statements), logical conditions, and comparisons. 

#### **5. str (String)**

A `str` represents a **sequence of Unicode characters** enclosed in single, double, or triple quotes.

* **Example:**


```python
greeting = "Hello, World!"
print(type(greeting))  # Output: <class 'str'>

```



* **Use Case:** Used in text processing, data storage, and user interactions. 

#### **6. tuple (Tuple)**

A `tuple` is an **ordered** collection of elements that is **immutable** (cannot be changed after creation).
* **Example:**


```python
coordinates = (10, 20, 30)
print(type(coordinates))  # Output: <class 'tuple'>

```
* **Use Case:** Used when a fixed collection of items is needed, such as days of the week or geographical coordinates. 

#### **7. frozenset (Immutable Set)**

A `frozenset` is an **unordered** collection of unique elements that **cannot be modified** after creation.
* **Example:**


```python
frozen_numbers = frozenset([1, 2, 3, 4, 5])
print(type(frozen_numbers))  # Output: <class 'frozenset'>

```
* **Use Case:** Used in scenarios where a set must remain constant, such as defining unchangeable configuration values.

#### **8. bytes (Byte Data Type)**

The `bytes` type represents a sequence of **immutable** 8-bit bytes, often used in binary data manipulation.
* **Example:**


```python
byte_data = b"hello"
print(type(byte_data))  # Output: <class 'bytes'>

```



* **Use Case:** Used in file handling, network communication, and cryptographic operations. 
#### **9. bytearray (Mutable Byte Data Type)**

A `bytearray` is similar to `bytes`, but it **allows modification** of byte values.



* **Example:**


```python
mutable_bytes = bytearray(5)
print(type(mutable_bytes))  # Output: <class 'bytearray'>

```



* **Use Case:** Used in applications that require modification of binary data, such as image or audio processing. 


#### **10. NoneType (None Value)**

`NoneType` represents the **absence of a value** and is commonly used as a default return value for functions that do not explicitly return anything.



* **Example:**


```python
x = None
print(type(x))  # Output: <class 'NoneType'>

```
* **Use Case:** Used in functions, placeholders, and optional values in variables. 

## **Mutable Data Types**


#### **1. list (List)**

A `list` is an **ordered and mutable** collection that can store different data types.



* **Example:**


```python
fruits = ["apple", "banana", "cherry"]
fruits.append("orange")
print(type(fruits))  # Output: <class 'list'>

```

* **Use Case:** Used when a dynamic collection of elements is needed, such as storing user inputs or database records. 

#### **2. set (Set)**

A `set` is an **unordered** collection of **unique** elements.

* **Example:**

```python
unique_numbers = {1, 2, 3, 4}
print(type(unique_numbers))  # Output: <class 'set'>

```

* **Use Case:** Used for mathematical operations like union, intersection, and removing duplicates. 

#### **3. dict (Dictionary)**

A `dict` stores **key-value pairs**, making it easy to retrieve values based on keys.

* **Example:**


```python
student = {"name": "Alice", "age": 20}
print(type(student))  # Output: <class 'dict'>

```
* **Use Case:** Used in APIs, configuration files, and structured data storage. 

#### **4. memoryview (Memory Management)**

The `memoryview` type allows direct manipulation of binary data without copying it.



* **Example:**

```python
data = memoryview(bytes(5))
print(type(data))  # Output: <class 'memoryview'>

```



* **Use Case:** Used in high-performance computing for efficient memory management. 



#### **5. array (Array)**

An `array` stores elements of the **same data type** (requires `array` module).



* **Example:**


```python
import array
arr = array.array('i', [1, 2, 3, 4])
print(type(arr))  # Output: <class 'array.array'>

```

* **Use Case:** Used in performance-sensitive applications requiring homogeneous data. 

#### **6. deque (Double-Ended Queue)**

A `deque` (double-ended queue) allows **fast insertion and removal** from both ends.

* **Example:**
```python
from collections import deque
dq = deque([1, 2, 3, 4])
print(type(dq))  # Output: <class 'collections.deque'>

```
* **Use Case:** Used in queue-based applications and sliding window problems. 

#### **7. object (Base Class)**

`object` is the base class from which all Python classes inherit.

* **Example:**
```python
class Sample:
    pass

obj = Sample()
print(type(obj))  # Output: <class '__main__.Sample'>

```
* **Use Case:** Used as a foundation for creating new classes. 
#### **8. types.SimpleNamespace (Dynamic Attribute Assignment)**

Allows dynamic assignment of attributes.

* **Example:**
```python
from types import SimpleNamespace
person = SimpleNamespace(name="John", age=30)
print(type(person))  # Output: <class 'types.SimpleNamespace'>
```
* **Use Case:** Used in object-like structures with dynamic properties. 

#### **Conclusion**

Understanding **Python’s built-in data types** allows for **efficient programming** and **better memory management**. Choosing the right data type improves **code performance, readability, and maintainability**.

---
19. ### What is Type Casting in Python

Type casting in Python refers to **converting a variable from one data type to another**. This is useful when performing operations that require a specific data type. Python provides two types of type casting:



1. **Implicit Type Casting (Automatic Conversion)**
2. **Explicit Type Casting (Manual Conversion)**




#### **1. Implicit Type Casting**


Python **automatically converts** a smaller data type to a larger one when required, without any user intervention. This prevents data loss.


#### **Example:**


```python
    a = 5    # int
    b = 2.5  # float
    result = a + b  # int + float → float
    print(result, type(result))  
    # Output: 7.5 <class 'float'>
```


**Explanation:**



* `a` (int) is automatically converted to `float` before addition. 

* The result is a `float`, ensuring no data loss. 


**Use Case:**



* When performing arithmetic operations between different numeric types. 





#### **2. Explicit Type Casting**


Explicit type casting is when we **manually** convert a variable from one type to another using Python’s built-in functions.


#### **Common Type Casting Functions in Python:**

| Function    | Description                                      | Example                 | Output  |
|------------|--------------------------------------------------|-------------------------|---------|
| `int(x)`   | Converts `x` to an integer.                     | `int(3.7)`              | `3`     |
| `float(x)` | Converts `x` to a floating-point number.        | `float(5)`              | `5.0`   |
| `str(x)`   | Converts `x` to a string.                      | `str(10)`               | `'10'`  |
| `bool(x)`  | Converts `x` to a boolean value.                | `bool(0)`               | `False` |
| `list(x)`  | Converts `x` to a list.                         | `list((1, 2, 3))`       | `[1,2,3]` |
| `tuple(x)` | Converts `x` to a tuple.                        | `tuple([4, 5, 6])`      | `(4,5,6)` |
| `set(x)`   | Converts `x` to a set (unique elements only).   | `set([1, 2, 2, 3])`     | `{1,2,3}` |
| `dict(x)`  | Converts `x` to a dictionary (from key-value pairs). | `dict([(1, 'a'), (2, 'b')])` | `{1: 'a', 2: 'b'}` |
| `complex(x, y)` | Converts `x` and `y` into a complex number. | `complex(2, 3)` | `(2+3j)` |



#### **Example 1: Converting Float to Integer**


```python
    num = 5.9
    int_num = int(num)  
    print(int_num, type(int_num))  
    # Output: 5 <class 'int'>
```


**Explanation:**



* The decimal part is removed, leaving only the integer value. 


**Use Case:**



* Used when whole numbers are needed, such as array indexing. 


---


#### **Example 2: Converting Integer to String**


```python
num = 100
str_num = str(num)  
print(str_num, type(str_num))  
# Output: '100' <class 'str'>

```


**Explanation:**


* The integer `100` is converted to a string `'100'`. 


**Use Case:**



* Useful when concatenating numbers with text. 


#### **Example 3: Converting String to Integer**


```python
num_str = "50"
num_int = int(num_str)  
print(num_int + 10)  
# Output: 60

```


**Explanation:**

* The string `"50"` is converted into an integer `50`, enabling arithmetic operations. 

**Use Case:**

* Often used when receiving user input, which is always a string by default. 


#### **Example 4: Converting List to Tuple**


```python
my_list = [1, 2, 3]
my_tuple = tuple(my_list)  
print(my_tuple, type(my_tuple))  
# Output: (1, 2, 3) <class 'tuple'>
```


**Explanation:**



* The list `[1, 2, 3]` is converted into a tuple `(1, 2, 3)`. 


**Use Case:**



* Used when an immutable version of a list is required. 





#### **Summary**

* **Implicit Type Casting**: Python automatically converts smaller types to larger types. 

* **Explicit Type Casting**: The user manually converts types using built-in functions. 

* Type casting is useful for **ensuring compatibility** in operations and handling user input correctly.

[Back to Top](#table-of-content) 
---
20. ### What are global and local variables


In Python, **variables have scope**, which determines where a variable can be accessed. Variables can be **global** or **local**, depending on where they are declared.


#### **Local Variables**

A **local variable** is declared **inside a function** and can only be used within that function. It is created when the function is called and destroyed when the function execution is complete.

**Example:**


```python
def my_function():
    x = 10  # Local variable
    print("Inside function:", x)

my_function()
   # print(x)  # This would cause an error because 'x' is local to     the function.
```


**Output:**


```python
Inside function: 10
```


*(Trying to access x outside the function would cause an error.)*


#### **Global Variables**

A **global variable** is declared **outside any function** and can be accessed throughout the program.

**Example:**


```python
y = 20  # Global variable
def another_function():
        print("Inside function:", y)  # Accessible inside the function
another_function()
    print("Outside function:", y)  # Also accessible outside
```


**Output:**

```python
Inside function: 20

Outside function: 20
```


*(The variable y is accessible inside and outside the function.)*




#### **Using global  Keyword**

If a function needs to modify a global variable, the globall keyword must be used.

**Example:**


```python
    z = 5  # Global variable

    def modify_global():
        global z  # Declaring z as a global variable
        z = 15  # Modifying the global variable

    modify_global()
    print("Updated global variable:", z)
```


**Output**


```python
    Updated global variable: 15
```


*(The global variable z  is modified inside the function using the global keyword.)*

#### Key Differences Between Local and Global Variables
| Feature            | Local Variable                  | Global Variable                   |
|--------------------|--------------------------------|----------------------------------|
| **Declared Inside** | A function                     | Outside any function            |
| **Scope**         | Only within the function       | Entire program                  |
| **Lifetime**      | Created when function is called, destroyed when function ends | Exists as long as the program runs |
| **Access Outside Function** | ❌ No (Causes an error) | ✅ Yes (Accessible everywhere) |
| **Modification Inside Function** | Possible without `global` keyword | Requires `global` keyword |


